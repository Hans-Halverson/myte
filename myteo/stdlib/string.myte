module std.string

import std.bool.Bool
import std.byte.Byte
import std.int.Int
import std.ops.Equatable
import std.memory.Array
import std.sys.abort

type alias Char = Byte

type String {
  data: Array<Char>,
  size: Int,
  capacity: Int,
}

methods String {
  static fun new(): String {
    return String {
      data: Array.new(0),
      size: 0,
      capacity: 0,
    };
  }

  fun get(index: Int): Char {
    if (index >= this.size) {
      abort();
    }

    return this.data[index];
  }

  fun set(index: Int, item: Char) {
    if (index >= this.size) {
      abort();
    }

    this.data[index] = item;
  }

  fun push(char: Char) {
    if (this.size == this.capacity) {
      this.resize();
    }

    this.data[this.size] = char;
    this.size = this.size + 1;
  }

  fun append(str: String) {
    val newSize = this.size + str.size;
    if (newSize > this.capacity) {
      this.resizeWithMinCapacity(newSize);
    }

    Array.copy(this.data, this.size, str.data, 0, str.size);
    this.size = newSize;
  }

  fun resize() {
    val oldCapacity = this.capacity;
    var newCapacity = oldCapacity * 2;
    if (newCapacity == 0) {
      newCapacity = 1;
    }
    this.capacity = newCapacity;

    val newData: Array<Char> = Array.new(newCapacity);
    Array.copy(newData, 0, this.data, 0, oldCapacity);
    this.data = newData;
  }

  fun resizeWithMinCapacity(minCapacity: Int) {
    val oldCapacity = this.capacity;
    var newCapacity = oldCapacity * 2;
    if (newCapacity == 0) {
      newCapacity = 1;
    } else if (newCapacity < minCapacity) {
      newCapacity = minCapacity;
    }
    this.capacity = newCapacity;

    val newData: Array<Char> = Array.new(newCapacity);
    Array.copy(newData, 0, this.data, 0, oldCapacity);
    this.data = newData;
  }

  fun reverse() {
    val size = this.size;
    val oldData = this.data;
    val newData: Array<Char> = Array.new(size);
    this.data = newData;
    this.capacity = size;

    var i = 0;
    while (i < size) {
      newData[size - (i + 1)] = oldData[i];
      i = i + 1;
    }
  }
}

methods String {
  implements Equatable

  override fun equals(other: String): Bool {
    val size = this.size;
    if (size != other.size) {
      return false;
    }

    val thisData = this.data;
    val otherData = other.data;

    var i = 0;
    while (i < size) {
      if (thisData[i] != otherData[i]) {
        return false;
      }

      i = i + 1;
    }

    return true;
  }
}

trait ToString {
  fun toString(): String
}

methods String {
  implements ToString

  override fun toString(): String = this
}