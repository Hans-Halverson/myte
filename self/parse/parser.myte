module myte.parse.parser

import std.io.println

import std.sys.exit

import myte.common.files.readFileContents
import myte.common.loc.{Loc, START_POS}
import myte.parse.ast
import myte.parse.error
import myte.parse.error.{ParseError, fatal}
import myte.parse.lexer.{ErrorResult, Lexer, TokenResult}
import myte.parse.token
import myte.parse.token.Token

type Parser {
  lexer: Lexer,
  token: Token,
  loc: Loc,
  prevToken: Token,
  prevLoc: Loc,
}

methods Parser {
  static fun new(lexer: Lexer): Parser {
    val TokenResult { token, loc } = match (lexer.next()) {
      | Ok (result) -> result
      | Error (ErrorResult { error, loc }) -> fatal(error, loc)
    };

    return Parser {
      lexer,
      token,
      loc,
      prevToken: token,
      prevLoc: loc,
    };
  }

  fun advance() {
    val TokenResult { token, loc } = match (this.lexer.next()) {
      | Ok (result) -> result
      | Error (ErrorResult { error, loc }) -> fatal(error, loc)
    };

    val prevToken = this.token;
    val prevLoc = this.loc;

    this.token = token;
    this.loc = loc;

    this.prevToken = prevToken;
    this.prevLoc = prevLoc;
  }

  fun expect(expected: Token) {
    val actual = this.token;
    if (!actual.equals(expected)) {
      val error = error.UnexpectedToken { actual, expected: Some (expected) };
      fatal(error, this.loc);
    }

    this.advance();
  }

  fun currentLoc(start: Loc): Loc = Loc.between(start, this.prevLoc)

  fun parse(): ast.Module {
    val name = this.parseModuleName();

    val toplevels: Vec<ast.Toplevel> = [];
    while (!this.token.equals(token.Eof)) {
      toplevels.push(this.parseToplevel());
    }

    val startLoc = Loc { source: this.loc.source, start: START_POS, end: START_POS };
    val loc = Loc.between(startLoc, this.loc);

    return ast.Module { loc, name, toplevels };
  }

  fun parseModuleName(): ast.ModuleName {
    val startLoc = this.loc;
    this.expect(token.Module);

    val name = this.parseScopedIdentifier();
    val loc = this.currentLoc(startLoc);

    return ast.ModuleName { loc, name };
  }

  fun parseToplevel(): ast.Toplevel {
    return match (this.token) {
      | token.Fun -> ast.TLFunction (this.parseFunctionDeclaration(this.loc, false, false, false))
      | token.Val
      | token.Var -> ast.TLVariable (this.parseVariableDeclaration(true))
      | token.Type -> ast.TLType (this.parseTypeDeclaration(false))
      | token -> fatal(error.MalformedToplevel { token }, this.loc)
    };
  }

  fun parseIdentifier(): ast.Identifier {
    match (this.token) {
      | token.Identifier (name) -> {
        val loc = this.loc;
        this.advance();
        return ast.Identifier { loc, name };
      }
      | actual -> {
        val error = error.UnexpectedToken { actual, expected: Some (token.Identifier ("")) };
        return fatal(error, this.loc);
      }
    }
  }

  fun parseScopedIdentifier(): ast.ScopedIdentifier {
    val startLoc = this.loc;

    val scopes: Vec<ast.Identifier> = [];
    var name = this.parseIdentifier();

    while (this.token.equals(token.Period)) {
      this.advance();
      scopes.push(name);
      name = this.parseIdentifier();
    }

    val loc = this.currentLoc(startLoc);

    return ast.ScopedIdentifier { loc, scopes, name };
  }

  /* 
   * ============================
   *        Declarations
   * ============================
   */

  fun parseFunctionDeclaration(
    startLoc: Loc,
    isBuiltin: Bool,
    isStatic: Bool,
    isOverride: Bool,
  ): ast.FunctionDeclaration {
    this.expect(token.Fun);

    val name = this.parseIdentifier();
    val typeParams = this.parseTypeParameters();

    // Parse function parameters
    val params: Vec<ast.FunctionParam> = [];
    this.expect(token.LeftParen);

    while (!this.token.equals(token.RightParen)) {
      val startLoc = this.loc;
      val name = this.parseIdentifier();
      this.expect(token.Colon);
      val annot = this.parseType();

      val loc = this.currentLoc(startLoc);
      params.push(ast.FunctionParam { loc, name, annot });

      match (this.token) {
        | token.RightParen -> ()
        | token.Comma -> this.advance()
        | _ -> this.expect(token.RightParen)
      }
    }

    this.advance();

    // Parse optional return type
    val ret = match (this.token) {
      | token.Colon -> {
        this.advance();
        Some (this.parseType())
      }
      | _ -> None
    };

    // Parse function body
    val body = match (this.token) {
      | token.LeftBrace -> ast.FBBlock (this.parseBlock())
      | token -> fatal(error.MalformedFunctionBody { token }, this.loc)
    };

    val loc = this.currentLoc(startLoc);

    return ast.FunctionDeclaration
      { loc, name, params, body, ret, typeParams, isBuiltin, isStatic, isOverride };
  }

  fun parseVariableDeclaration(isToplevel: Bool): ast.VariableDeclaration {
    val startLoc = this.loc;
    val kind = if (this.token.equals(token.Val)) {
      ast.Immutable
    } else {
      ast.Mutable
    };

    this.advance();

    val pattern = this.parseScopedIdentifier();
    val annot = if (this.token.equals(token.Colon)) {
      this.advance();
      Some (this.parseType())
    } else {
      None
    };

    this.expect(token.Equals);
    val init = this.parseExpression();
    if (!isToplevel) {
      this.expect(token.Semicolon);
    }

    val loc = this.currentLoc(startLoc);

    return ast.VariableDeclaration { loc, kind, pattern, annot, init };
  }

  fun parseTypeDeclaration(isBuiltin: Bool): ast.TypeDeclaration {
    val startLoc = this.loc;
    this.expect(token.Type);

    // Parse type alias if alias keyword is encountered
    if (this.token.equals(token.Alias)) {
      this.advance();

      val name = this.parseIdentifier();
      val typeParams = this.parseTypeParameters();
      this.expect(token.Equals);
      val ty = this.parseType();
      val loc = this.currentLoc(startLoc);

      return ast.TypeDeclaration { loc, name, typeParams, decl: ast.TDAlias (ty) };
    }

    val nameStartLoc = this.loc;
    val name = this.parseIdentifier();
    val typeParams = this.parseTypeParameters();

    // Builtin types only have a name and type parameters
    if (isBuiltin) {
      val loc = this.currentLoc(startLoc);
      return ast.TypeDeclaration { loc, name, typeParams, decl: ast.TDBuiltin };
    }

    return match (this.token) {
      // A left paren following the name signifies a single tuple variant
      | token.LeftParen -> {
        val tuple = this.parseTupleDeclaration(name, nameStartLoc);
        val loc = this.currentLoc(startLoc);

        return ast.TypeDeclaration { loc, name, typeParams, decl: ast.TDTuple (tuple) };
      }
      // A left brace following the name signifies a single record variant
      | token.LeftBrace -> {
        val record = this.parseRecordDeclaration(name, nameStartLoc);
        val loc = this.currentLoc(startLoc);

        return ast.TypeDeclaration { loc, name, typeParams, decl: ast.TDRecord (record) };
      }
      // Otherwise there are multiple variants in this declaration
      | token.Equals -> {
        this.advance();
        val variants = this.parseVariants();
        val loc = this.currentLoc(startLoc);

        if (variants.size == 1) {
          fatal(error.SingleVariant, loc);
        }

        return ast.TypeDeclaration { loc, name, typeParams, decl: ast.TDVariant (variants) };
      }
      | _ -> fatal(error.MalformedTypeDeclaration { token: this.token }, this.loc)
    };
  }

  fun parseVariants(): Vec<ast.VariantDeclaration> {
    // Variants may optionally have a leading pipe
    match (this.token) {
      | token.Pipe -> this.advance()
      | _ -> ()
    }

    val variants: Vec<ast.VariantDeclaration> = [];
    while (true) {
      val startLoc = this.loc;
      val name = this.parseIdentifier();

      val variant = match (this.token) {
        | token.LeftParen -> ast.TupleVariant (this.parseTupleDeclaration(name, startLoc))
        | token.LeftBrace -> ast.RecordVariant (this.parseRecordDeclaration(name, startLoc))
        | _ -> ast.EnumVariant (name)
      };

      variants.push(variant);

      match (this.token) {
        | token.Pipe -> this.advance()
        | _ -> break
      }
    }

    return variants;
  }

  fun parseTupleDeclaration(name: ast.Identifier, startLoc: Loc): ast.TupleDeclaration {
    this.expect(token.LeftParen);

    val elements: Vec<ast.Type> = [];
    while (this.token != token.RightParen) {
      elements.push(this.parseType());
      match (this.token) {
        | token.RightParen -> ()
        | token.Comma -> this.advance()
        | _ -> this.expect(token.RightParen)
      }
    }

    this.advance();
    val loc = this.currentLoc(startLoc);

    if (elements.size == 0) {
      fatal(error.EmptyTuple, loc);
    }

    return ast.TupleDeclaration { loc, name, elements };
  }

  fun parseRecordDeclaration(name: ast.Identifier, startLoc: Loc): ast.RecordDeclaration {
    this.expect(token.LeftBrace);

    val fields: Vec<ast.RecordDeclarationField> = [];
    while (this.token != token.RightBrace) {
      val startLoc = this.loc;
      val name = this.parseIdentifier();
      this.expect(token.Colon);
      val ty = this.parseType();
      val loc = this.currentLoc(startLoc);

      fields.push(ast.RecordDeclarationField { loc, name, ty });

      match (this.token) {
        | token.RightBrace -> ()
        | token.Comma -> this.advance()
        | _ -> this.expect(token.RightBrace)
      }
    }

    this.advance();
    val loc = this.currentLoc(startLoc);

    if (fields.size == 0) {
      fatal(error.EmptyRecord, loc);
    }

    return ast.RecordDeclaration { loc, name, fields };
  }

  fun parseTypeParameters(): Vec<ast.TypeParameter> {
    if (this.token != token.LessThan) {
      return [];
    }

    this.advance();

    // List of type params must be nonempty
    if (this.token == token.GreaterThan) {
      this.expect(token.Identifier (""));
      return [];
    }

    val typeParams: Vec<ast.TypeParameter> = [];
    while (this.token != token.GreaterThan) {
      val startLoc = this.loc;
      val name = this.parseIdentifier();

      // Parse type parameter bounds if any are provided
      val bounds = match (this.token) {
        | token.Colon -> {
          this.advance();

          // Bounds are separated with a potentially trailing ampersand
          val bounds = [this.parseIdentifierType()];
          while (this.token == token.Ampersand) {
            this.advance();
            match (this.token) {
              | token.Comma
              | token.GreaterThan -> break
              | _ -> bounds.push(this.parseIdentifierType())
            }
          }

          bounds
        }
        | _ -> []
      };

      val loc = this.currentLoc(startLoc);
      typeParams.push(ast.TypeParameter { loc, name, bounds });

      match (this.token) {
        | token.GreaterThan -> ()
        | token.Comma -> this.advance()
        | _ -> this.expect(token.GreaterThan)
      }
    }

    this.advance();

    return typeParams;
  }

  /* 
   * ============================
   *        Statements
   * ============================
   */

  fun parseStatement(): ast.Statement {
    return match (this.token) {
      | token.LeftBrace -> ast.SBlock (this.parseBlock())
      | token.Val
      | token.Var -> ast.SVariableDeclaration (this.parseVariableDeclaration(false))
      | token.While -> ast.SWhile (this.parseWhile())
      | token.Return -> ast.SReturn (this.parseReturn(false))
      | token.Break -> ast.SBreak (this.parseBreak(false))
      | token.Continue -> ast.SContinue (this.parseContinue(false))
      | _ -> this.parseAssignmentOrExpressionStatement()
    };
  }

  fun parseBlock(): ast.Block {
    val startLoc = this.loc;
    this.expect(token.LeftBrace);

    val statements: Vec<ast.Statement> = [];
    while (!this.token.equals(token.RightBrace)) {
      statements.push(this.parseStatement());
    }

    this.advance();
    val loc = this.currentLoc(startLoc);

    return ast.Block { loc, statements };
  }

  fun parseAssignmentOrExpressionStatement(): ast.Statement {
    val startLoc = this.loc;
    val expr = this.parseExpression();

    // An expression statement must be terminated by a semicolon unless it is the last statement
    // in a block, in which case it is the value of the block.
    val isValue = if (this.token.equals(token.RightBrace)) {
      true
    } else {
      this.expect(token.Semicolon);
      false
    };

    val loc = this.currentLoc(startLoc);

    return ast.SExpression (ast.ExpressionStatement { loc, expr, isValue });
  }

  fun parseWhile(): ast.While {
    val startLoc = this.loc;
    this.expect(token.While);

    // Parse test and block body
    this.expect(token.LeftParen);
    val test = this.parseExpression();
    this.expect(token.RightParen);
    val body = this.parseBlock();

    val loc = this.currentLoc(startLoc);

    return ast.While { loc, test, body };
  }

  fun parseReturn(inMatchCase: Bool): ast.Return {
    val startLoc = this.loc;
    this.expect(token.Return);

    // Parse return argument
    val arg = match (this.token) {
      | token.Semicolon -> None
      /* Handle the following cases:
         match (x) {
           | a -> return
         }

         match (x) {
           | a -> return
           | b -> c
         } */
      | token.Pipe
      | token.RightBrace when inMatchCase -> None
      | _ -> Some (this.parseExpression())
    };

    if (!inMatchCase) {
      this.expect(token.Semicolon);
    }

    val loc = this.currentLoc(startLoc);

    return ast.Return { loc, arg };
  }

  fun parseBreak(inMatchCase: Bool): ast.Break {
    val startLoc = this.loc;
    this.expect(token.Break);
    if (!inMatchCase) {
      this.expect(token.Semicolon);
    }

    val loc = this.currentLoc(startLoc);

    return ast.Break { loc };
  }

  fun parseContinue(inMatchCase: Bool): ast.Continue {
    val startLoc = this.loc;
    this.expect(token.Continue);
    if (!inMatchCase) {
      this.expect(token.Semicolon);
    }

    val loc = this.currentLoc(startLoc);

    return ast.Continue { loc };
  }

  /* 
   * ============================
   *        Expressions
   * ============================
   */

  fun parseExpression(): ast.Expression {
    return match (this.token) {
      | token.Identifier _ -> ast.EIdentifier (this.parseIdentifier())
      | token.LeftParen -> this.parseParenthesizedExpression()
      | token.IntLiteral { raw, base } -> {
        val loc = this.loc;
        this.advance();
        ast.EIntLiteral (ast.IntLiteral { loc, raw, base })
      }
      | token.BoolLiteral (value) -> {
        val loc = this.loc;
        this.advance();
        ast.EBoolLiteral (ast.BoolLiteral { loc, value })
      }
      | token.StringLiteral (value) -> {
        val loc = this.loc;
        this.advance();
        ast.EStringLiteral (ast.StringLiteral { loc, value })
      }
      | actual -> fatal(error.UnexpectedToken { actual, expected: None }, this.loc)
    };
  }

  fun parseParenthesizedExpression(): ast.Expression {
    val startLoc = this.loc;
    this.expect(token.LeftParen);

    // A set of empty parens is a unit literal
    if (this.token.equals(token.RightParen)) {
      this.advance();
      val loc = this.currentLoc(startLoc);

      return ast.EUnitLiteral (ast.UnitLiteral { loc });
    }

    val expr = this.parseExpression();
    return match (this.token) {
      // A colon following an expression represents the start of a type cast `(expr: ty)`
      | token.Colon -> {
        this.advance();
        val ty = this.parseType();
        this.expect(token.RightParen);
        val loc = this.currentLoc(startLoc);

        ast.ETypeCast (ast.TypeCast { loc, expr, ty })
      }
      // A colon following an expression represents a tuple expression
      | token.Comma -> {
        val commaLoc = this.loc;
        this.advance();

        // Error if this would be parsed as a single element tuple with a trailing comma
        if (this.token.equals(token.RightParen)) {
          val error = error.UnexpectedToken {
            actual: token.Comma,
            expected: Some (token.RightParen),
          };
          fatal(error, commaLoc);
        }

        // Parse elements of tuple expression
        val elements = [expr]; 
        while (!this.token.equals(token.RightParen)) {
          elements.push(this.parseExpression());
          match (this.token) {
            | token.RightParen -> ()
            | token.Comma -> this.advance()
            | _ -> this.expect(token.RightParen)
          }
        }

        this.advance();
        val loc = this.currentLoc(startLoc);

        ast.ETuple (ast.TupleExpression { loc, elements })
      }
      // Otherwise this must be a single parenthesized expression
      | _ -> {
        this.expect(token.RightParen);
        expr
      }
    };
  }

  /* 
   * ============================
   *           Types
   * ============================
   */

  fun parseType(): ast.Type {
    return match(this.token) {
      | token.Identifier _ -> ast.TIdentifier (this.parseIdentifierType())
      | token.LeftParen -> this.parseParenthesizedType()
      | token.Trait -> ast.TTrait (this.parseTraitType())
      | token -> fatal(error.MalformedType { token }, this.loc)
    };
  }

  fun parseIdentifierType(): ast.IdentifierType {
    val startLoc = this.loc;
    val name = this.parseScopedIdentifier();
    val typeArgs = this.parseTypeArgs();
    val loc = this.currentLoc(startLoc);

    return ast.IdentifierType { loc, name, typeArgs };
  }

  fun parseParenthesizedType(): ast.Type {
    val startLoc = this.loc;
    this.advance();

    // Parse comma separated elements in parenthesized list
    val elements: Vec<ast.Type> = [];

    // If list is empty then must be a part of function type or else error on right paren
    if (this.token == token.RightParen) {
      val rightParenLoc = this.loc;
      this.advance();

      match (this.token) {
        | token.Arrow -> ()
        | _ ->
          fatal(error.UnexpectedToken { actual: token.RightParen, expected: None }, rightParenLoc)
      }
    } else {
      // Parse comma separated elements in list
      while (true) {
        elements.push(this.parseType());

        match (this.token) {
          // End of list with no trailing comma
          | token.RightParen -> {
            this.advance();
            break;
          }
          | token.Comma -> {
            val commaLoc = this.loc;
            this.advance();

            // End of list with trailing comma
            if (this.token == token.RightParen) {
              this.advance();

              // Single element with trailing comma, error if not part of a function type
              if (elements.size == 1 && this.token != token.Arrow) {
                val error = error.UnexpectedToken {
                  actual: token.Comma,
                  expected: Some (token.RightParen),
                };
                fatal(error, commaLoc);
              }

              break;
            }
          }
          | _ -> this.expect(token.RightParen)
        }
      }
    }

    // A parenthesized list followed by an arrow is a function type
    if (this.token == token.Arrow) {
      this.advance();
      val return_ = this.parseType();
      val loc = this.currentLoc(startLoc);

      return ast.TFunction (ast.FunctionType { loc, params: elements, return_ });
    }

    // A parenthesized list with one item is just a parenthesized type, otherwise it is a tuple type
    return if (elements.size == 1) {
      elements[0]
    } else {
      val loc = this.currentLoc(startLoc);
      ast.TTuple (ast.TupleType  { loc, elements })
    };
  }

  fun parseTraitType(): ast.TraitType {
    val startLoc = this.loc;
    this.advance();
    val trait_ = this.parseIdentifierType();
    val loc = this.currentLoc(startLoc);

    return ast.TraitType { loc, trait_ };
  }

  fun parseTypeArgs(): Vec<ast.Type> {
    if (!this.token.equals(token.LessThan)) {
      return [];
    }

    this.advance();

    // List of type args must be nonempty
    if (this.token.equals(token.GreaterThan)) {
      this.expect(token.Identifier (""));
    }

    val typeArgs: Vec<ast.Type> = [];
    while (!this.token.equals(token.GreaterThan)) {
      typeArgs.push(this.parseType());

      match (this.token) {
        | token.GreaterThan -> ()
        | token.Comma -> this.advance()
        | _ -> this.expect(token.GreaterThan)
      }
    }

    this.advance();

    return typeArgs;
  }
}

fun parseFile(filename: String): Result<ast.Module, ParseError> {
  val contents = match (readFileContents(filename)) {
    | Ok (contents) -> contents
    | Error _ -> return Error (error.CannotOpenFile { filename })
  };

  val lexer = Lexer.new(filename, contents);
  val parser = Parser.new(lexer);
  val mod = parser.parse();

  return Ok (mod);
}
