module myte.parse.parser

import std.io.println

import std.sys.{abort, exit}

import myte.common.files.readFileContents
import myte.common.loc.{Loc, START_POS}
import myte.parse.ast
import myte.parse.error
import myte.parse.error.{ParseError, fatal}
import myte.parse.lexer.{ErrorResult, Lexer, TokenResult}
import myte.parse.precedence
import myte.parse.precedence.Precedence
import myte.parse.token
import myte.parse.token.Token

type Parser {
  lexer: Lexer,
  token: Token,
  loc: Loc,
  prevToken: Token,
  prevLoc: Loc,
  // Whether the lexer should currently be lexing an interpolated string 
  inInterpolatedString: Bool,
  // A stack of bools where each bool represents whether bitwise or is not allowed
  // in the enclosing matches.
  matchStack: Vec<Bool>,
}

methods Parser {
  static fun new(lexer: Lexer): Parser {
    val TokenResult { token, loc } = match (lexer.next()) {
      | Ok (result) -> result
      | Error (ErrorResult { error, loc }) -> fatal(error, loc)
    };

    return Parser {
      lexer,
      token,
      loc,
      prevToken: token,
      prevLoc: loc,
      inInterpolatedString: false,
      matchStack: [false],
    };
  }

  fun lexerNext(): Result<TokenResult, ErrorResult> {
    return if (this.inInterpolatedString) {
      this.lexer.nextInInterpolatedString()
    } else {
      this.lexer.next()
    };
  }

  fun advance() {
    val TokenResult { token: newToken, loc: newLoc } = match (this.lexerNext()) {
      | Ok (result) -> result
      | Error (ErrorResult { error, loc }) -> fatal(error, loc)
    };

    val prevToken = this.token;
    val prevLoc = this.loc;

    this.token = newToken;
    this.loc = newLoc;

    this.prevToken = prevToken;
    this.prevLoc = prevLoc;

    // Track whether whether parser is in top level of match statement
    if (!this.inInterpolatedString) {
      match (this.prevToken) {
        | token.LeftParen
        | token.LeftBrace
        | token.LeftBracket -> this.matchStack.push(false)
        | token.RightParen
        | token.RightBrace
        | token.RightBracket -> {
          this.matchStack.pop();
        }
        | _ -> ()
      }
    }
  }

  fun expect(expected: Token) {
    val actual = this.token;
    if (!actual.equals(expected)) {
      val error = error.UnexpectedToken { actual, expected: Some (expected) };
      fatal(error, this.loc);
    }

    this.advance();
  }

  fun peek(): TokenResult {
    val savedLexer = this.lexer.clone();
    val tokenResult = match (this.lexerNext()) {
      | Ok (result) -> result
      | Error (ErrorResult { error, loc }) -> fatal(error, loc)
    };
    this.lexer = savedLexer;

    return tokenResult;
  }

  fun enterInterpolatedString() {
    this.inInterpolatedString = true;
  }

  fun exitInterpolatedString() {
    this.inInterpolatedString = false;
  }

  fun enterMatch() {
    this.matchStack.push(true);
  }

  fun exitMatch() {
    this.matchStack.pop();
  }

  fun canUseBitwiseOr(): Bool {
    return !this.matchStack[this.matchStack.size - 1];
  }

  fun currentLoc(start: Loc): Loc = Loc.between(start, this.prevLoc)

  fun parse(): ast.Module {
    val name = this.parseModuleName();

    val imports: Vec<ast.Import> = [];
    while (this.token == token.Import) {
      imports.push(this.parseImport());
    }

    val toplevels: Vec<ast.Toplevel> = [];
    while (this.token != token.Eof) {
      toplevels.push(this.parseToplevel());
    }

    val startLoc = Loc { source: this.loc.source, start: START_POS, end: START_POS };
    val loc = Loc.between(startLoc, this.loc);

    return ast.Module { loc, name, imports, toplevels };
  }

  fun parseModuleName(): ast.ModuleName {
    val startLoc = this.loc;
    this.expect(token.Module);

    val name = this.parseScopedIdentifier();
    val loc = this.currentLoc(startLoc);

    return ast.ModuleName { loc, name };
  }

  fun parseImport(): ast.Import {
    val startLoc = this.loc;
    this.expect(token.Import);

    // Gather scopes and final name until end or '{' is reached
    var name = this.parseIdentifier();
    val scopes: Vec<ast.Identifier> = [];
    while (this.token == token.Period) {
      this.advance();

      match (this.token) {
        | token.LeftBrace -> break
        | _ -> {
          scopes.push(name);
          name = this.parseIdentifier();
        }
      }
    }

    return match (this.token) {
      // If a left brace follows scopes this is a complex import
      | token.LeftBrace -> {
        scopes.push(name);
        ast.IComplexImport (this.parseComplexImport(scopes, startLoc))
      }
      // Otherwise it is a simple import - a single scoped identifier
      | _ -> {
        val loc = this.currentLoc(startLoc);
        ast.ISimpleImport (ast.ScopedIdentifier { loc, name, scopes })
      }
    };
  }

  fun parseComplexImport(scopes: Vec<ast.Identifier>, startLoc: Loc): ast.ComplexImport {
    this.expect(token.LeftBrace);

    // Parse all import aliases
    val aliases: Vec<ast.ImportAlias> = [];
    while (true) {
      val startLoc = this.loc;
      val name = this.parseIdentifier();

      // Parse optional alias
      val alias_ = match (this.token) {
        | token.As -> {
          this.advance();
          Some (this.parseIdentifier())
        }
        | _ -> None
      };

      val loc = this.currentLoc(startLoc);
      aliases.push(ast.ImportAlias { loc, name, alias_ });

      // Only proceed to another alias if there is a comma followed by an identifier. Otherwise
      // if there is no comma, or the comma is trailing, expect a right brace next.
      match (this.token) {
        | token.Comma -> {
          this.advance();
          match (this.token) {
            | token.Identifier _ -> ()
            | _ -> break
          }
        }
        | _ -> break
      }
    }

    this.expect(token.RightBrace);
    val loc = this.currentLoc(startLoc);

    return ast.ComplexImport { loc, scopes, aliases };
  }

  fun parseToplevel(): ast.Toplevel {
    return match (this.token) {
      | token.Fun -> ast.TLFunction (this.parseFunctionDeclaration(this.loc, false, false, false))
      | token.Val
      | token.Var -> ast.TLVariable (this.parseVariableDeclaration(true))
      | token.Type -> ast.TLType (this.parseTypeDeclaration(false))
      | token -> fatal(error.MalformedToplevel { token }, this.loc)
    };
  }

  fun parseIdentifier(): ast.Identifier {
    match (this.token) {
      | token.Identifier (name) -> {
        val loc = this.loc;
        this.advance();
        return ast.Identifier { loc, name };
      }
      | actual -> {
        val error = error.UnexpectedToken { actual, expected: Some (token.Identifier ("")) };
        return fatal(error, this.loc);
      }
    }
  }

  fun parseScopedIdentifier(): ast.ScopedIdentifier {
    val startLoc = this.loc;

    val scopes: Vec<ast.Identifier> = [];
    var name = this.parseIdentifier();

    while (this.token.equals(token.Period)) {
      this.advance();
      scopes.push(name);
      name = this.parseIdentifier();
    }

    val loc = this.currentLoc(startLoc);

    return ast.ScopedIdentifier { loc, scopes, name };
  }

  /* 
   * ============================
   *        Declarations
   * ============================
   */

  fun parseFunctionDeclaration(
    startLoc: Loc,
    isBuiltin: Bool,
    isStatic: Bool,
    isOverride: Bool,
  ): ast.FunctionDeclaration {
    this.expect(token.Fun);

    val name = this.parseIdentifier();
    val typeParams = this.parseTypeParameters();

    // Parse function parameters
    val params: Vec<ast.FunctionParam> = [];
    this.expect(token.LeftParen);

    while (!this.token.equals(token.RightParen)) {
      val startLoc = this.loc;
      val name = this.parseIdentifier();
      this.expect(token.Colon);
      val annot = this.parseType();

      val loc = this.currentLoc(startLoc);
      params.push(ast.FunctionParam { loc, name, annot });

      match (this.token) {
        | token.RightParen -> ()
        | token.Comma -> this.advance()
        | _ -> this.expect(token.RightParen)
      }
    }

    this.advance();

    // Parse optional return type
    val ret = match (this.token) {
      | token.Colon -> {
        this.advance();
        Some (this.parseType())
      }
      | _ -> None
    };

    // Parse function body
    val body = match (this.token) {
      | token.LeftBrace -> ast.FBBlock (this.parseBlock())
      | token.Equals -> {
        this.advance();
        ast.FBExpression (this.parseExpression())
      }
      | token -> fatal(error.MalformedFunctionBody { token }, this.loc)
    };

    val loc = this.currentLoc(startLoc);

    return ast.FunctionDeclaration
      { loc, name, params, body, ret, typeParams, isBuiltin, isStatic, isOverride };
  }

  fun parseVariableDeclaration(isToplevel: Bool): ast.VariableDeclaration {
    val startLoc = this.loc;
    val kind = if (this.token.equals(token.Val)) {
      ast.Immutable
    } else {
      ast.Mutable
    };

    this.advance();

    val pattern = this.parsePattern(true);
    val annot = if (this.token.equals(token.Colon)) {
      this.advance();
      Some (this.parseType())
    } else {
      None
    };

    this.expect(token.Equals);
    val init = this.parseExpression();
    if (!isToplevel) {
      this.expect(token.Semicolon);
    }

    val loc = this.currentLoc(startLoc);

    return ast.VariableDeclaration { loc, kind, pattern, annot, init };
  }

  fun parseTypeDeclaration(isBuiltin: Bool): ast.TypeDeclaration {
    val startLoc = this.loc;
    this.expect(token.Type);

    // Parse type alias if alias keyword is encountered
    if (this.token.equals(token.Alias)) {
      this.advance();

      val name = this.parseIdentifier();
      val typeParams = this.parseTypeParameters();
      this.expect(token.Equals);
      val ty = this.parseType();
      val loc = this.currentLoc(startLoc);

      return ast.TypeDeclaration { loc, name, typeParams, decl: ast.TDAlias (ty) };
    }

    val nameStartLoc = this.loc;
    val name = this.parseIdentifier();
    val typeParams = this.parseTypeParameters();

    // Builtin types only have a name and type parameters
    if (isBuiltin) {
      val loc = this.currentLoc(startLoc);
      return ast.TypeDeclaration { loc, name, typeParams, decl: ast.TDBuiltin };
    }

    return match (this.token) {
      // A left paren following the name signifies a single tuple variant
      | token.LeftParen -> {
        val tuple = this.parseTupleDeclaration(name, nameStartLoc);
        val loc = this.currentLoc(startLoc);

        return ast.TypeDeclaration { loc, name, typeParams, decl: ast.TDTuple (tuple) };
      }
      // A left brace following the name signifies a single record variant
      | token.LeftBrace -> {
        val record = this.parseRecordDeclaration(name, nameStartLoc);
        val loc = this.currentLoc(startLoc);

        return ast.TypeDeclaration { loc, name, typeParams, decl: ast.TDRecord (record) };
      }
      // Otherwise there are multiple variants in this declaration
      | token.Equals -> {
        this.advance();
        val variants = this.parseVariants();
        val loc = this.currentLoc(startLoc);

        if (variants.size == 1) {
          fatal(error.SingleVariant, loc);
        }

        return ast.TypeDeclaration { loc, name, typeParams, decl: ast.TDVariant (variants) };
      }
      | _ -> fatal(error.MalformedTypeDeclaration { token: this.token }, this.loc)
    };
  }

  fun parseVariants(): Vec<ast.VariantDeclaration> {
    // Variants may optionally have a leading pipe
    match (this.token) {
      | token.Pipe -> this.advance()
      | _ -> ()
    }

    val variants: Vec<ast.VariantDeclaration> = [];
    while (true) {
      val startLoc = this.loc;
      val name = this.parseIdentifier();

      val variant = match (this.token) {
        | token.LeftParen -> ast.TupleVariant (this.parseTupleDeclaration(name, startLoc))
        | token.LeftBrace -> ast.RecordVariant (this.parseRecordDeclaration(name, startLoc))
        | _ -> ast.EnumVariant (name)
      };

      variants.push(variant);

      match (this.token) {
        | token.Pipe -> this.advance()
        | _ -> break
      }
    }

    return variants;
  }

  fun parseTupleDeclaration(name: ast.Identifier, startLoc: Loc): ast.TupleDeclaration {
    this.expect(token.LeftParen);

    val elements: Vec<ast.Type> = [];
    while (this.token != token.RightParen) {
      elements.push(this.parseType());
      match (this.token) {
        | token.RightParen -> ()
        | token.Comma -> this.advance()
        | _ -> this.expect(token.RightParen)
      }
    }

    this.advance();
    val loc = this.currentLoc(startLoc);

    if (elements.size == 0) {
      fatal(error.EmptyTuple, loc);
    }

    return ast.TupleDeclaration { loc, name, elements };
  }

  fun parseRecordDeclaration(name: ast.Identifier, startLoc: Loc): ast.RecordDeclaration {
    this.expect(token.LeftBrace);

    val fields: Vec<ast.RecordDeclarationField> = [];
    while (this.token != token.RightBrace) {
      val startLoc = this.loc;
      val name = this.parseIdentifier();
      this.expect(token.Colon);
      val ty = this.parseType();
      val loc = this.currentLoc(startLoc);

      fields.push(ast.RecordDeclarationField { loc, name, ty });

      match (this.token) {
        | token.RightBrace -> ()
        | token.Comma -> this.advance()
        | _ -> this.expect(token.RightBrace)
      }
    }

    this.advance();
    val loc = this.currentLoc(startLoc);

    if (fields.size == 0) {
      fatal(error.EmptyRecord, loc);
    }

    return ast.RecordDeclaration { loc, name, fields };
  }

  fun parseTypeParameters(): Vec<ast.TypeParameter> {
    if (this.token != token.LessThan) {
      return [];
    }

    this.advance();

    // List of type params must be nonempty
    if (this.token == token.GreaterThan) {
      this.expect(token.Identifier (""));
      return [];
    }

    val typeParams: Vec<ast.TypeParameter> = [];
    while (this.token != token.GreaterThan) {
      val startLoc = this.loc;
      val name = this.parseIdentifier();

      // Parse type parameter bounds if any are provided
      val bounds = match (this.token) {
        | token.Colon -> {
          this.advance();

          // Bounds are separated with a potentially trailing ampersand
          val bounds = [this.parseIdentifierType()];
          while (this.token == token.Ampersand) {
            this.advance();
            match (this.token) {
              | token.Comma
              | token.GreaterThan -> break
              | _ -> bounds.push(this.parseIdentifierType())
            }
          }

          bounds
        }
        | _ -> []
      };

      val loc = this.currentLoc(startLoc);
      typeParams.push(ast.TypeParameter { loc, name, bounds });

      match (this.token) {
        | token.GreaterThan -> ()
        | token.Comma -> this.advance()
        | _ -> this.expect(token.GreaterThan)
      }
    }

    this.advance();

    return typeParams;
  }

  /* 
   * ============================
   *        Statements
   * ============================
   */

  fun parseStatement(): ast.Statement {
    return match (this.token) {
      | token.LeftBrace -> ast.SBlock (this.parseBlock())
      | token.Val
      | token.Var -> ast.SVariableDeclaration (this.parseVariableDeclaration(false))
      | token.Match -> ast.SMatch (this.parseMatch(false))
      | token.While -> ast.SWhile (this.parseWhile())
      | token.Return -> ast.SReturn (this.parseReturn(false))
      | token.Break -> ast.SBreak (this.parseBreak(false))
      | token.Continue -> ast.SContinue (this.parseContinue(false))
      | _ -> this.parseAssignmentOrExpressionStatement()
    };
  }

  fun parseBlock(): ast.Block {
    val startLoc = this.loc;
    this.expect(token.LeftBrace);

    val statements: Vec<ast.Statement> = [];
    while (!this.token.equals(token.RightBrace)) {
      statements.push(this.parseStatement());
    }

    this.advance();
    val loc = this.currentLoc(startLoc);

    return ast.Block { loc, statements };
  }

  fun parseAssignmentOrExpressionStatement(): ast.Statement {
    val startLoc = this.loc;
    val expr = this.parseExpression();

    // An expression statement must be terminated by a semicolon unless it is the last statement
    // in a block, in which case it is the value of the block.
    val isValue = if (this.token.equals(token.RightBrace)) {
      true
    } else {
      this.expect(token.Semicolon);
      false
    };

    val loc = this.currentLoc(startLoc);

    return ast.SExpression (ast.ExpressionStatement { loc, expr, isValue });
  }

  fun parseMatch(isExpression: Bool): ast.Match {
    val startLoc = this.loc;
    this.expect(token.Match);

    // Parse nonempty arguments list
    this.expect(token.LeftParen);
    val args: Vec<ast.Expression> = [];

    while (true) {
      args.push(this.parseExpression());

      // Args are separated by commas and end at right paren, with optional trailing comma
      match (this.token) {
        | token.RightParen -> break
        | token.Comma -> {
          this.advance();

          // May be a trailing comma, finish args if so
          if (this.token == token.RightParen) {
            break;
          }
        }
        | _ -> this.expect(token.RightParen)
      }
    }

    this.expect(token.RightParen);

    // Parse match cases
    this.expect(token.LeftBrace);
    this.enterMatch();

    // Pipe for first case is optional
    if (this.token == token.Pipe) {
      this.advance();
    }

    val cases: Vec<ast.MatchCase> = [];
    while (true) {
      cases.push(this.parseMatchCase(isExpression));

      // A pipe following a match case means another case follows, otherwise must be end of body
      match (this.token) {
        | token.RightBrace -> break
        | token.Pipe -> this.advance()
        | _ -> this.expect(token.RightBrace)
      }
    }

    this.expect(token.RightBrace);
    this.exitMatch();

    val loc = this.currentLoc(startLoc);

    return ast.Match { loc, args, cases };
  }

  fun parseMatchCase(isExpression: Bool): ast.MatchCase {
    val startLoc = this.loc;

    // Parse pattern with optional match guard
    val pattern = this.parsePattern(false);
    val guard = if (this.token == token.When) {
      this.advance();
      Some (this.parseExpression())
    } else {
      None
    };

    this.expect(token.Arrow);

    // Parse body of match case. Only certain statements are allowed as body of match case.
    val body = match (this.token) {
      | token.LeftBrace -> ast.MCStatement (ast.SBlock (this.parseBlock()))
      | token.While -> ast.MCStatement (ast.SWhile (this.parseWhile()))
      | token.Return -> ast.MCStatement (ast.SReturn (this.parseReturn(true)))
      | token.Break -> ast.MCStatement (ast.SBreak (this.parseBreak(true)))
      | token.Continue -> ast.MCStatement (ast.SContinue (this.parseContinue(true)))
      | token.Match -> {
        val match_ = this.parseMatch(isExpression);
        if (isExpression) {
          ast.MCExpression (ast.EMatch (match_))
        } else {
          ast.MCStatement (ast.SMatch (match_))
        }
      }
      | _ -> ast.MCExpression (this.parseExpression())
    };

    val loc = this.currentLoc(startLoc);

    return ast.MatchCase { loc, pattern, guard, body };
  }

  fun parseWhile(): ast.While {
    val startLoc = this.loc;
    this.expect(token.While);

    // Parse test and block body
    this.expect(token.LeftParen);
    val test = this.parseExpression();
    this.expect(token.RightParen);
    val body = this.parseBlock();

    val loc = this.currentLoc(startLoc);

    return ast.While { loc, test, body };
  }

  fun parseReturn(inMatchCase: Bool): ast.Return {
    val startLoc = this.loc;
    this.expect(token.Return);

    // Parse return argument
    val arg = match (this.token) {
      | token.Semicolon -> None
      /* Handle the following cases:
         match (x) {
           | a -> return
         }

         match (x) {
           | a -> return
           | b -> c
         } */
      | token.Pipe
      | token.RightBrace when inMatchCase -> None
      | _ -> Some (this.parseExpression())
    };

    if (!inMatchCase) {
      this.expect(token.Semicolon);
    }

    val loc = this.currentLoc(startLoc);

    return ast.Return { loc, arg };
  }

  fun parseBreak(inMatchCase: Bool): ast.Break {
    val startLoc = this.loc;
    this.expect(token.Break);
    if (!inMatchCase) {
      this.expect(token.Semicolon);
    }

    val loc = this.currentLoc(startLoc);

    return ast.Break { loc };
  }

  fun parseContinue(inMatchCase: Bool): ast.Continue {
    val startLoc = this.loc;
    this.expect(token.Continue);
    if (!inMatchCase) {
      this.expect(token.Semicolon);
    }

    val loc = this.currentLoc(startLoc);

    return ast.Continue { loc };
  }

  /* 
   * ============================
   *        Expressions
   * ============================
   */

  fun parseExpression(): ast.Expression {
    return this.parseExpressionWithPrecedence(precedence.Toplevel);
  }

  fun parseExpressionWithPrecedence(leftPrecedence: Precedence): ast.Expression {
    val startLoc = this.loc;

    var expr = this.parseExpressionPrefix();
    while (true) {
      expr = match (this.token) {
        | token.LeftParen when leftPrecedence.isWeakerThan(precedence.Call) ->
          ast.ECall (this.parseCall(expr, startLoc))
        | token.Period when leftPrecedence.isWeakerThan(precedence.Access) ->
          ast.ENamedAccess (this.parseNamedAccess(expr, startLoc))
        | token.LeftBracket when leftPrecedence.isWeakerThan(precedence.Access) ->
          ast.EIndexedAccess (this.parseIndexedAccess(expr, startLoc))
        | token.Plus
        | token.Minus when leftPrecedence.isWeakerThan(precedence.Addition) ->
          ast.EBinaryOperation (this.parseBinaryOperation(expr, startLoc))
        | token.Multiply
        | token.Divide
        | token.Percent when leftPrecedence.isWeakerThan(precedence.Multiplication) ->
          ast.EBinaryOperation (this.parseBinaryOperation(expr, startLoc))
        | token.Ampersand when leftPrecedence.isWeakerThan(precedence.BitwiseAnd) ->
          ast.EBinaryOperation (this.parseBinaryOperation(expr, startLoc))
        | token.Pipe
            when leftPrecedence.isWeakerThan(precedence.BitwiseOr) && this.canUseBitwiseOr() ->
          ast.EBinaryOperation (this.parseBinaryOperation(expr, startLoc))
        | token.Caret when leftPrecedence.isWeakerThan(precedence.BitwiseXor) ->
          ast.EBinaryOperation (this.parseBinaryOperation(expr, startLoc))
        | token.LessThanOrEqual
        | token.GreaterThanOrEqual when leftPrecedence.isWeakerThan(precedence.Comparison) ->
          ast.EBinaryOperation (this.parseBinaryOperation(expr, startLoc))
        | token.DoubleEquals
        | token.NotEquals when leftPrecedence.isWeakerThan(precedence.Equality) ->
          ast.EBinaryOperation (this.parseBinaryOperation(expr, startLoc))
        | token.LogicalAnd when leftPrecedence.isWeakerThan(precedence.LogicalAnd) ->
          ast.ELogicalAnd (this.parseLogicalAnd(expr, startLoc))
        | token.LogicalOr when leftPrecedence.isWeakerThan(precedence.LogicalOr) ->
          ast.ELogicalOr (this.parseLogicalOr(expr, startLoc))
        | token.Question when leftPrecedence.isWeakerThan(precedence.Unwrap) ->
          ast.EUnwrap (this.parseUnwrap(expr, startLoc))
        // A less than can be the start of a comparison or left shift
        | token.LessThan -> {
          // Two adjacent less thans are a left shift
          val TokenResult { token: secondToken, loc: secondLoc } = this.peek();
          if (secondToken == token.LessThan &&
              leftPrecedence.isWeakerThan(precedence.BitwiseShift) &&
              this.loc.isAdjacentTo(secondLoc)) {
            ast.EBinaryOperation(this.parseLeftShift(expr, startLoc))
          } else if (leftPrecedence.isWeakerThan(precedence.Comparison)) {
            // Otherwise it is a les than comparison
            ast.EBinaryOperation(this.parseLessThan(expr, startLoc))
          } else {
            break;
          }
        }
        // A greater than can be the start of a comparison or right shift
        | token.GreaterThan -> {
          // Two adjacent greater thans must be a right shift
          val TokenResult { token: secondToken, loc: secondLoc } = this.peek();
          if (secondToken == token.GreaterThan &&
              leftPrecedence.isWeakerThan(precedence.BitwiseShift) &&
              this.loc.isAdjacentTo(secondLoc)) {
            this.expect(token.GreaterThan);
            this.expect(token.GreaterThan);

            // A third adjacent greater than is a logical right shift, otherwise arithmetic
            if (this.token == token.GreaterThan && secondLoc.isAdjacentTo(this.loc)) {
              ast.EBinaryOperation(this.parseLogicalRightShift(expr, startLoc))
            } else {
              ast.EBinaryOperation(this.parseArithmeticRightShift(expr, startLoc))
            }
          } else if (leftPrecedence.isWeakerThan(precedence.Comparison)) {
            // Otherwise it is a greater than comparison
            ast.EBinaryOperation(this.parseGreaterThan(expr, startLoc))
          } else {
            break;
          }
        }
        | _ -> break
      };
    }

    return expr;
  }

  fun parseExpressionPrefix(): ast.Expression {
    return match (this.token) {
      | token.Identifier _ -> ast.EIdentifier (this.parseIdentifier())
      | token.LeftParen -> this.parseParenthesizedExpression()
      | token.IntLiteral { raw, base } -> {
        val loc = this.loc;
        this.advance();
        ast.EIntLiteral (ast.IntLiteral { loc, raw, base })
      }
      | token.BoolLiteral (value) -> {
        val loc = this.loc;
        this.advance();
        ast.EBoolLiteral (ast.BoolLiteral { loc, value })
      }
      | token.StringLiteral (value) -> {
        val loc = this.loc;
        this.advance();
        ast.EStringLiteral (ast.StringLiteral { loc, value })
      }
      | token.CharLiteral (value) -> {
        val loc = this.loc;
        this.advance();
        ast.ECharLiteral (ast.CharLiteral { loc, value })
      }
      | token.InterpolatedString { string, isEnd } ->
        ast.EInterpolatedString (this.parseInterpolatedString(string, isEnd))
      | token.Match -> ast.EMatch (this.parseMatch(true))
      | token.Plus -> ast.EUnaryOperation (this.parseUnaryPlus())
      | token.Minus -> this.parseUnaryMinusOrNegativeIntLiteral()
      | token.Bang -> ast.EUnaryOperation (this.parseUnaryNot())
      | actual -> fatal(error.UnexpectedToken { actual, expected: None }, this.loc)
    };
  }

  fun parseParenthesizedExpression(): ast.Expression {
    val startLoc = this.loc;
    this.expect(token.LeftParen);

    // A set of empty parens is a unit literal
    if (this.token.equals(token.RightParen)) {
      this.advance();
      val loc = this.currentLoc(startLoc);

      return ast.EUnitLiteral (ast.UnitLiteral { loc });
    }

    val expr = this.parseExpression();
    return match (this.token) {
      // A colon following an expression represents the start of a type cast `(expr: ty)`
      | token.Colon -> {
        this.advance();
        val ty = this.parseType();
        this.expect(token.RightParen);
        val loc = this.currentLoc(startLoc);

        ast.ETypeCast (ast.TypeCast { loc, expr, ty })
      }
      // A colon following an expression represents a tuple expression
      | token.Comma -> {
        val commaLoc = this.loc;
        this.advance();

        // Error if this would be parsed as a single element tuple with a trailing comma
        if (this.token.equals(token.RightParen)) {
          val error = error.UnexpectedToken {
            actual: token.Comma,
            expected: Some (token.RightParen),
          };
          fatal(error, commaLoc);
        }

        // Parse elements of tuple expression
        val elements = [expr]; 
        while (!this.token.equals(token.RightParen)) {
          elements.push(this.parseExpression());
          match (this.token) {
            | token.RightParen -> ()
            | token.Comma -> this.advance()
            | _ -> this.expect(token.RightParen)
          }
        }

        this.advance();
        val loc = this.currentLoc(startLoc);

        ast.ETuple (ast.TupleExpression { loc, elements })
      }
      // Otherwise this must be a single parenthesized expression
      | _ -> {
        this.expect(token.RightParen);
        expr
      }
    };
  }

  fun parseCall(func: ast.Expression, startLoc: Loc): ast.Call {
    this.expect(token.LeftParen);

    val args: Vec<ast.Expression> = [];
    while (this.token != token.RightParen) {
      args.push(this.parseExpression());

      match (this.token) {
        | token.RightParen -> ()
        | token.Comma -> this.advance()
        | _ -> this.expect(token.RightParen)
      }
    }

    this.advance();
    val loc = this.currentLoc(startLoc);

    return ast.Call { loc, func, args };
  }

  fun parseNamedAccess(target: ast.Expression, startLoc: Loc): ast.NamedAccess {
    this.expect(token.Period);
    val name = this.parseIdentifier();
    val loc = this.currentLoc(startLoc);

    return ast.NamedAccess { loc, target, name };
  }

  fun parseIndexedAccess(target: ast.Expression, startLoc: Loc): ast.IndexedAccess {
    this.expect(token.LeftBracket);
    val index = this.parseExpression();
    this.expect(token.RightBracket);
    val loc = this.currentLoc(startLoc);

    return ast.IndexedAccess { loc, target, index };
  }

  fun parseUnaryPlus(): ast.UnaryOperation {
    val startLoc = this.loc;
    this.expect(token.Plus);
    val operand = this.parseExpressionWithPrecedence(precedence.Unary);
    val loc = this.currentLoc(startLoc);

    return ast.UnaryOperation { loc, op: ast.UnaryPlus, operand };
  }

  fun parseUnaryNot(): ast.UnaryOperation {
    val startLoc = this.loc;
    this.expect(token.Bang);
    val operand = this.parseExpressionWithPrecedence(precedence.Unary);
    val loc = this.currentLoc(startLoc);

    return ast.UnaryOperation { loc, op: ast.UnaryNot, operand };
  }

  fun parseUnaryMinusOrNegativeIntLiteral(): ast.Expression {
    val startLoc = this.loc;
    this.expect(token.Minus);

    return match (this.token) { 
      // When a minus is followed by an int literal with no space between them, it is a negative
      // int literal.
      | token.IntLiteral { raw, base } when startLoc.isAdjacentTo(this.loc) -> {
        this.advance();
        val raw = `-${raw}`;
        val loc = this.currentLoc(startLoc);

        return ast.EIntLiteral (ast.IntLiteral { loc, raw, base });
      }
      // Otherwise this is a unary minus expression
      | _ -> {
        val operand = this.parseExpressionWithPrecedence(precedence.Unary);
        val loc = this.currentLoc(startLoc);

        return ast.EUnaryOperation (ast.UnaryOperation { loc, op: ast.UnaryMinus, operand });
      }
    };
  }

  fun parseBinaryOperation(left: ast.Expression, startLoc: Loc): ast.BinaryOperation {
    val (op, precedence) = match (this.token) {
      | token.Plus -> (ast.BinaryAdd, precedence.Addition)
      | token.Minus -> (ast.BinarySubtract, precedence.Addition)
      | token.Multiply -> (ast.BinaryMultiply, precedence.Multiplication)
      | token.Divide -> (ast.BinaryDivide, precedence.Multiplication)
      | token.Percent -> (ast.BinaryRemainder, precedence.Multiplication)
      | token.Ampersand -> (ast.BinaryBitwiseAnd, precedence.BitwiseAnd)
      | token.Pipe -> (ast.BinaryBitwiseOr, precedence.BitwiseOr)
      | token.Caret -> (ast.BinaryBitwiseXor, precedence.BitwiseXor)
      | token.DoubleEquals -> (ast.BinaryEqual, precedence.Equality)
      | token.NotEquals -> (ast.BinaryNotEqual, precedence.Equality)
      | token.LessThanOrEqual -> (ast.BinaryLessThanOrEqual, precedence.Comparison)
      | token.GreaterThanOrEqual -> (ast.BinaryGreaterThanOrEqual, precedence.Comparison)
      // Unreachable
      | _ -> abort()
    };

    this.advance();
    val right = this.parseExpressionWithPrecedence(precedence);
    val loc = this.currentLoc(startLoc);

    return ast.BinaryOperation { loc, op, left, right };
  }

  fun parseLogicalAnd(left: ast.Expression, startLoc: Loc): ast.LogicalAnd {
    this.expect(token.LogicalAnd);
    val right = this.parseExpressionWithPrecedence(precedence.LogicalAnd);
    val loc = this.currentLoc(startLoc);

    return ast.LogicalAnd { loc, left, right };
  }

  fun parseLogicalOr(left: ast.Expression, startLoc: Loc): ast.LogicalOr {
    this.expect(token.LogicalOr);
    val right = this.parseExpressionWithPrecedence(precedence.LogicalOr);
    val loc = this.currentLoc(startLoc);

    return ast.LogicalOr { loc, left, right };
  }

  fun parseLessThan(left: ast.Expression, startLoc: Loc): ast.BinaryOperation {
    this.expect(token.LessThan);
    val right = this.parseExpressionWithPrecedence(precedence.Comparison);
    val loc = this.currentLoc(startLoc);

    return ast.BinaryOperation { loc, op: ast.BinaryLessThan, left, right };
  }

  fun parseGreaterThan(left: ast.Expression, startLoc: Loc): ast.BinaryOperation {
    this.expect(token.GreaterThan);
    val right = this.parseExpressionWithPrecedence(precedence.Comparison);
    val loc = this.currentLoc(startLoc);

    return ast.BinaryOperation { loc, op: ast.BinaryGreaterThan, left, right };
  }

  fun parseLeftShift(left: ast.Expression, startLoc: Loc): ast.BinaryOperation {
    this.expect(token.LessThan);
    this.expect(token.LessThan);
    val right = this.parseExpressionWithPrecedence(precedence.BitwiseShift);
    val loc = this.currentLoc(startLoc);

    return ast.BinaryOperation { loc, op: ast.BinaryLeftShift, left, right };
  }

  fun parseArithmeticRightShift(left: ast.Expression, startLoc: Loc): ast.BinaryOperation {
    val right = this.parseExpressionWithPrecedence(precedence.BitwiseShift);
    val loc = this.currentLoc(startLoc);

    return ast.BinaryOperation { loc, op: ast.BinaryArithmeticRightShift, left, right };
  }

  fun parseLogicalRightShift(left: ast.Expression, startLoc: Loc): ast.BinaryOperation {
    this.expect(token.GreaterThan);
    val right = this.parseExpressionWithPrecedence(precedence.BitwiseShift);
    val loc = this.currentLoc(startLoc);

    return ast.BinaryOperation { loc, op: ast.BinaryLogicalRightShift, left, right };
  }

  fun parseUnwrap(operand: ast.Expression, startLoc: Loc): ast.Unwrap {
    this.expect(token.Question);
    val loc = this.currentLoc(startLoc);

    return ast.Unwrap { loc, operand };
  }

  fun parseInterpolatedString(firstString: String, isSinglePart: Bool): ast.InterpolatedString {
    val startLoc = this.loc;
    val loc = startLoc;
    this.advance();

    if (isSinglePart) {
      return ast.InterpolatedString {
        loc,
        parts: [ast.IPString (ast.StringLiteral { loc, value: firstString })],
     };
    }

    // String parts are only included if they are nonempy, e.g. `${expr1}${expr2}` has two
    // expression parts and no string parts.
    val parts: Vec<ast.InterpolatedStringPart> = [];
    if (firstString.size != 0) {
      parts.push(ast.IPString (ast.StringLiteral { loc, value: firstString }));
    }

    while (true) {
      parts.push(ast.IPExpression (this.parseExpression()));

      // Enter interpolated string mode before call to `advance` within `expect`. This ensures the
      // token after the right brace is lexed as an interpolated string token.
      this.enterInterpolatedString();
      this.expect(token.RightBrace);
      
      match (this.token) {
        | token.InterpolatedString { string, isEnd } -> {
          this.exitInterpolatedString();
          val loc = this.loc;
          this.advance();

          if (string.size != 0) {
            parts.push(ast.IPString (ast.StringLiteral { loc, value: string }));
          }

          if (isEnd) {
            break;
          }
        }
        // Unreachable, interpolated string is always returned when parsing interpolated strings
        | _ -> break
      }
    }

    val loc = this.currentLoc(loc);

    return ast.InterpolatedString { loc, parts };
  }

  /* 
   * ============================
   *           Types
   * ============================
   */

  fun parseType(): ast.Type {
    return match(this.token) {
      | token.Identifier _ -> ast.TIdentifier (this.parseIdentifierType())
      | token.LeftParen -> this.parseParenthesizedType()
      | token.Trait -> ast.TTrait (this.parseTraitType())
      | token -> fatal(error.MalformedType { token }, this.loc)
    };
  }

  fun parseIdentifierType(): ast.IdentifierType {
    val startLoc = this.loc;
    val name = this.parseScopedIdentifier();
    val typeArgs = this.parseTypeArgs();
    val loc = this.currentLoc(startLoc);

    return ast.IdentifierType { loc, name, typeArgs };
  }

  fun parseParenthesizedType(): ast.Type {
    val startLoc = this.loc;
    this.advance();

    // Parse comma separated elements in parenthesized list
    val elements: Vec<ast.Type> = [];

    // If list is empty then must be a part of function type or else error on right paren
    if (this.token == token.RightParen) {
      val rightParenLoc = this.loc;
      this.advance();

      match (this.token) {
        | token.Arrow -> ()
        | _ ->
          fatal(error.UnexpectedToken { actual: token.RightParen, expected: None }, rightParenLoc)
      }
    } else {
      // Parse comma separated elements in list
      while (true) {
        elements.push(this.parseType());

        match (this.token) {
          // End of list with no trailing comma
          | token.RightParen -> {
            this.advance();
            break;
          }
          | token.Comma -> {
            val commaLoc = this.loc;
            this.advance();

            // End of list with trailing comma
            if (this.token == token.RightParen) {
              this.advance();

              // Single element with trailing comma, error if not part of a function type
              if (elements.size == 1 && this.token != token.Arrow) {
                val error = error.UnexpectedToken {
                  actual: token.Comma,
                  expected: Some (token.RightParen),
                };
                fatal(error, commaLoc);
              }

              break;
            }
          }
          | _ -> this.expect(token.RightParen)
        }
      }
    }

    // A parenthesized list followed by an arrow is a function type
    if (this.token == token.Arrow) {
      this.advance();
      val return_ = this.parseType();
      val loc = this.currentLoc(startLoc);

      return ast.TFunction (ast.FunctionType { loc, params: elements, return_ });
    }

    // A parenthesized list with one item is just a parenthesized type, otherwise it is a tuple type
    return if (elements.size == 1) {
      elements[0]
    } else {
      val loc = this.currentLoc(startLoc);
      ast.TTuple (ast.TupleType  { loc, elements })
    };
  }

  fun parseTraitType(): ast.TraitType {
    val startLoc = this.loc;
    this.advance();
    val trait_ = this.parseIdentifierType();
    val loc = this.currentLoc(startLoc);

    return ast.TraitType { loc, trait_ };
  }

  fun parseTypeArgs(): Vec<ast.Type> {
    if (!this.token.equals(token.LessThan)) {
      return [];
    }

    this.advance();

    // List of type args must be nonempty
    if (this.token.equals(token.GreaterThan)) {
      this.expect(token.Identifier (""));
    }

    val typeArgs: Vec<ast.Type> = [];
    while (!this.token.equals(token.GreaterThan)) {
      typeArgs.push(this.parseType());

      match (this.token) {
        | token.GreaterThan -> ()
        | token.Comma -> this.advance()
        | _ -> this.expect(token.GreaterThan)
      }
    }

    this.advance();

    return typeArgs;
  }

  /* 
   * ============================
   *          Patterns
   * ============================
   */

  fun parsePattern(isDecl: Bool): ast.Pattern {
    return this.parsePatternWithPrecedence(isDecl, precedence.Toplevel);
  }

  fun parsePatternWithPrecedence(isDecl: Bool, leftPrecedence: Precedence): ast.Pattern {
    val startLoc = this.loc;

    var pattern = this.parsePatternPrefix(isDecl);
    while (true) {
      pattern = match (this.token) {
        | token.Pipe when leftPrecedence.isWeakerThan(precedence.BitwiseOr) -> {
          this.advance();
          val right = this.parsePatternWithPrecedence(isDecl, precedence.BitwiseOr);
          val loc = this.currentLoc(startLoc);

          ast.POr (ast.OrPattern { loc, left: pattern, right })
        }
        | token.As -> {
          this.advance();
          val name = this.parseIdentifier();
          val loc = this.currentLoc(startLoc);

          ast.PBinding (ast.BindingPattern { loc, pattern, name })
        }
        | _ -> break    
      };
    }

    return pattern;
  }

  fun parsePatternPrefix(isDecl: Bool): ast.Pattern {
    return match (this.token) {
      | token.Wildcard -> {
        val loc = this.loc;
        this.advance();

        ast.PWildcard (loc)
      }
      | token.Identifier (ident) -> this.parseIdentifierPattern(isDecl)
      | token.LeftParen -> this.parseParenthesizedPattern(isDecl)
      // Literals in declaration patterns are not allowed
      | token.BoolLiteral _
      | token.IntLiteral _
      | token.CharLiteral _
      | token.StringLiteral _ when isDecl ->
        fatal(error.LiteralInPattern, this.loc)
      // Literals in non-declaration patterns are allowed
      | token.IntLiteral { raw, base } -> {
        val loc = this.loc;
        this.advance();
        ast.PLiteral (ast.PInt (ast.IntLiteral { loc, raw, base }))
      }
      | token.BoolLiteral (value) -> {
        val loc = this.loc;
        this.advance();
        ast.PLiteral (ast.PBool (ast.BoolLiteral { loc, value }))
      }
      | token.StringLiteral (value) -> {
        val loc = this.loc;
        this.advance();
        ast.PLiteral (ast.PString (ast.StringLiteral { loc, value }))
      }
      | token.CharLiteral (value) -> {
        val loc = this.loc;
        this.advance();
        ast.PLiteral (ast.PChar (ast.CharLiteral { loc, value }))
      }
      // Minus may be start of negative int literal if not in declaration
      | token.Minus when !isDecl -> {
        val minusLoc = this.loc;
        this.advance();

        match (this.token) {
          // For this to be a negative int literal, minus sign must be immediately followed by an
          // int literal with no space between them.
          | token.IntLiteral { raw, base } when minusLoc.isAdjacentTo(this.loc) -> {
            this.advance();
            val raw = `-${raw}`;
            val loc = this.currentLoc(minusLoc);

            ast.PLiteral (ast.PInt (ast.IntLiteral { loc, raw, base }))
          }
          | _ -> fatal(error.MalformedPattern { token: token.Minus }, minusLoc)
        }
      }
      | token -> fatal(error.MalformedPattern { token }, this.loc)
    };
  }

  fun parseIdentifierPattern(isDecl: Bool): ast.Pattern {
    val startLoc = this.loc;
    val name = this.parseScopedIdentifier();

    return match (this.token) {
      | token.Wildcard -> {
        this.advance();
        val loc = this.currentLoc(startLoc);

        ast.PNamedWildcard (ast.NamedWildcard { loc, name })
      }
      | token.LeftParen -> ast.PTuple (this.parseTuplePattern(name, startLoc, isDecl))
      | token.LeftBrace -> ast.PRecord (this.parseRecordPattern(name, startLoc, isDecl))
      | _ -> ast.PIdentifier (name)
    };
  }

  fun parseTuplePattern(name: ast.ScopedIdentifier, startLoc: Loc, isDecl: Bool): ast.TuplePattern {
    this.expect(token.LeftParen);

    val elements: Vec<ast.Pattern> = [];
    while (this.token != token.RightParen) {
      elements.push(this.parsePattern(isDecl));
      match (this.token) {
        | token.RightParen -> ()
        | token.Comma -> this.advance()
        | _ -> this.expect(token.RightParen)
      }
    }

    this.advance();
    val loc = this.currentLoc(startLoc);
    
    if (elements.size == 0) {
      fatal(error.EmptyTuple, loc);
    }

    return ast.TuplePattern { loc, name: Some (name), elements };
  }

  fun parseRecordPattern(
    name: ast.ScopedIdentifier,
    startLoc: Loc,
    isDecl: Bool,
  ): ast.RecordPattern {
    this.expect(token.LeftBrace);

    var rest = false;
    val fields: Vec<ast.RecordPatternField> = [];

    while (true) {
      match (this.token) {
        // Record ends with a right element
        | token.RightBrace -> {
          this.advance();
          break;
        }
        // `...` is a rest element, and must be last element in record
        | token.Period -> {
          this.expect(token.Period);
          this.expect(token.Period);
          this.expect(token.Period);
          rest = true;

          // Rest can optionally be followed by a trailing comma, then the record must end
          if (this.token == token.Comma) {
            this.advance();
          }
          
          this.expect(token.RightBrace);
          break;
        }
        // An identifier is the start of a record field
        | token.Identifier _ -> {
          val startLoc = this.loc;
          val name = this.parseIdentifier();

          // A colon indicates this field has both a name and value
          val field = if (this.token == token.Colon) {
            this.advance();
            val value = this.parsePattern(isDecl);
            val loc = this.currentLoc(startLoc);

            ast.RecordPatternField { loc, name: Some (name), value }
          } else {
            // Otherwise this is field shorthand with just a name
            val loc = this.currentLoc(startLoc);

            ast.RecordPatternField {
              loc,
              name: None,
              value: ast.PIdentifier (ast.utils.identifierToScopedIdentifier(name)),
            }
          };

          fields.push(field);

          // Optionally followed by a trailing comma
          match (this.token) {
            | token.RightBrace -> ()
            | token.Comma -> this.advance()
            | _ -> this.expect(token.RightBrace)
          }
        }
        | _ -> this.expect(token.RightParen)
      }
    }

    val loc = this.currentLoc(startLoc);

    if (fields.size == 0) {
      fatal(error.EmptyRecord, loc);
    }

    return ast.RecordPattern { loc, name, fields, rest };
  }

  fun parseParenthesizedPattern(isDecl: Bool): ast.Pattern {
    val startLoc = this.loc;
    this.expect(token.LeftParen);

    // A unit literal can appear in non-declaration patterns
    if (this.token == token.RightParen) {
      this.advance();
      val loc = this.currentLoc(startLoc);

      if (isDecl) {
        fatal(error.LiteralInPattern, loc);
      }

      return ast.PLiteral (ast.PUnit (ast.UnitLiteral { loc }));
    }

    // Gather parenthesized elements
    val elements: Vec<ast.Pattern> = [];
    while (this.token != token.RightParen) {
      elements.push(this.parsePattern(isDecl));
      match (this.token) {
        | token.RightParen -> ()
        | token.Comma -> this.advance()
        | _ -> this.expect(token.RightParen)
      }
    }

    this.advance();

    // If there is a single element this is a parenthesized pattern, otherwise it is a tuple pattern
    return if (elements.size == 1) {
      elements[0]
    } else {
      val loc = this.currentLoc(startLoc);
      ast.PTuple (ast.TuplePattern { loc, name: None, elements })
    };
  }
}

fun parseFile(filename: String): Result<ast.Module, ParseError> {
  val contents = match (readFileContents(filename)) {
    | Ok (contents) -> contents
    | Error _ -> return Error (error.CannotOpenFile { filename })
  };

  val lexer = Lexer.new(filename, contents);
  val parser = Parser.new(lexer);
  val mod = parser.parse();

  return Ok (mod);
}
