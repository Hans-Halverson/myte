module myte.parse.parser

import std.sys.{abort, exit}

import myte.common.files.readFileContents
import myte.common.loc.{Loc, START_POS}
import myte.parse.ast
import myte.parse.error
import myte.parse.error.{ParseError, fatal}
import myte.parse.lexer.{ErrorResult, Lexer, TokenResult}
import myte.parse.precedence
import myte.parse.precedence.Precedence
import myte.parse.token
import myte.parse.token.Token

type Parser {
  var lexer: Lexer,
  var token: Token,
  var loc: Loc,
  var prevToken: Token,
  var prevLoc: Loc,
  // Whether the lexer should currently be lexing an interpolated string 
  var inInterpolatedString: Bool,
  // A stack of bools where each bool represents whether bitwise or is not allowed
  // in the enclosing matches.
  matchStack: Vec<Bool>,
}

methods Parser {
  static fun new(lexer: Lexer): Parser {
    val TokenResult { token, loc } = match (lexer.next()) {
      | Ok (result) -> result
      | Error (ErrorResult { error, loc }) -> fatal(error, loc)
    };

    return Parser {
      lexer,
      token,
      loc,
      prevToken: token,
      prevLoc: loc,
      inInterpolatedString: false,
      matchStack: [false],
    };
  }

  fun lexerNext(): Result<TokenResult, ErrorResult> {
    return if (this.inInterpolatedString) {
      this.lexer.nextInInterpolatedString()
    } else {
      this.lexer.next()
    };
  }

  fun advance() {
    val TokenResult { token: newToken, loc: newLoc } = match (this.lexerNext()) {
      | Ok (result) -> result
      | Error (ErrorResult { error, loc }) -> fatal(error, loc)
    };

    val prevToken = this.token;
    val prevLoc = this.loc;

    this.token = newToken;
    this.loc = newLoc;

    this.prevToken = prevToken;
    this.prevLoc = prevLoc;

    // Track whether whether parser is in top level of match statement
    if (!this.inInterpolatedString) {
      match (this.prevToken) {
        | token.LeftParen
        | token.LeftBrace
        | token.LeftBracket -> this.matchStack.push(false)
        | token.RightParen
        | token.RightBrace
        | token.RightBracket -> {
          this.matchStack.pop();
        }
        | _ -> ()
      }
    }
  }

  fun expect(expected: Token) {
    val actual = this.token;
    if (actual != expected) {
      val error = error.UnexpectedToken { actual, expected: Some (expected) };
      fatal(error, this.loc);
    }

    this.advance();
  }

  fun peek(): TokenResult {
    val savedLexer = this.lexer.clone();
    val tokenResult = match (this.lexerNext()) {
      | Ok (result) -> result
      | Error (ErrorResult { error, loc }) -> fatal(error, loc)
    };
    this.lexer = savedLexer;

    return tokenResult;
  }

  fun enterInterpolatedString() {
    this.inInterpolatedString = true;
  }

  fun exitInterpolatedString() {
    this.inInterpolatedString = false;
  }

  fun enterMatch() {
    this.matchStack.push(true);
  }

  fun exitMatch() {
    this.matchStack.pop();
  }

  fun canUseBitwiseOr(): Bool {
    return !this.matchStack[this.matchStack.size - 1];
  }

  fun currentLoc(start: Loc): Loc = Loc.between(start, this.prevLoc)

  fun parse(): ast.Module {
    val name = this.parseModuleName();

    val imports: Vec<ast.Import> = [];
    while (this.token == token.Import) {
      imports.push(this.parseImport());
    }

    val toplevels: Vec<ast.Toplevel> = [];
    while (this.token != token.Eof) {
      toplevels.push(this.parseToplevel());
    }

    val startLoc = Loc { source: this.loc.source, start: START_POS, end: START_POS };
    val loc = Loc.between(startLoc, this.loc);

    return ast.Module { loc, name, imports, toplevels, source: this.lexer.source };
  }

  fun parseModuleName(): ast.ModuleName {
    val startLoc = this.loc;

    // First token in the file must always be `module`
    match (this.token) {
      | token.Module -> this.advance()
      | token -> fatal(error.MissingModule { token }, this.loc)
    }

    val name = this.parseScopedIdentifier();
    val loc = this.currentLoc(startLoc);

    return ast.ModuleName { loc, name };
  }

  fun parseImport(): ast.Import {
    val startLoc = this.loc;
    this.expect(token.Import);

    // Gather scopes and final name until end or '{' is reached
    var name = this.parseIdentifier();
    val scopes: Vec<ast.Identifier> = [];
    while (this.token == token.Period) {
      this.advance();

      match (this.token) {
        | token.LeftBrace -> break
        | _ -> {
          scopes.push(name);
          name = this.parseIdentifier();
        }
      }
    }

    return match (this.token) {
      // If a left brace follows scopes this is a complex import
      | token.LeftBrace -> {
        scopes.push(name);
        ast.IComplexImport (this.parseComplexImport(scopes, startLoc))
      }
      // Otherwise it is a simple import - a single scoped identifier
      | _ -> {
        val loc = this.currentLoc(startLoc);
        ast.ISimpleImport (ast.ScopedIdentifier { loc, name, scopes })
      }
    };
  }

  fun parseComplexImport(scopes: Vec<ast.Identifier>, startLoc: Loc): ast.ComplexImport {
    this.expect(token.LeftBrace);

    // Parse all import aliases
    val aliases: Vec<ast.ImportAlias> = [];
    while (true) {
      val startLoc = this.loc;
      val name = this.parseIdentifier();

      // Parse optional alias
      val alias_ = match (this.token) {
        | token.As -> {
          this.advance();
          Some (this.parseIdentifier())
        }
        | _ -> None
      };

      val loc = this.currentLoc(startLoc);
      aliases.push(ast.ImportAlias { loc, name, alias_ });

      // Only proceed to another alias if there is a comma followed by an identifier. Otherwise
      // if there is no comma, or the comma is trailing, expect a right brace next.
      match (this.token) {
        | token.Comma -> {
          this.advance();
          match (this.token) {
            | token.Identifier _ -> ()
            | _ -> break
          }
        }
        | _ -> break
      }
    }

    this.expect(token.RightBrace);
    val loc = this.currentLoc(startLoc);

    return ast.ComplexImport { loc, scopes, aliases };
  }

  fun parseToplevel(): ast.Toplevel {
    val startLoc = this.loc;
    val attributes = this.parseAttributes();
    val isPublic = this.maybeParsePublic();
    return match (this.token) {
      | token.Fun ->
        ast.TLFunction (
          this.parseFunctionDeclaration(startLoc, attributes, isPublic, false, false, false, false),
        )
      | token.Val
      | token.Var ->
        ast.TLVariable (this.parseVariableDeclaration(startLoc, true, attributes, isPublic))
      | token.Type -> ast.TLType (this.parseTypeDeclaration(startLoc, attributes, isPublic, false))
      | token.Trait ->
        ast.TLTrait (this.parseTraitDeclaration(ast.TKTrait, startLoc, attributes, isPublic))
      | token.Methods when isPublic -> fatal(error.PublicMethodsBlock, startLoc)
      | token.Methods ->
        ast.TLTrait (this.parseTraitDeclaration(ast.TKMethods, startLoc, attributes, isPublic))
      // A builtin declaration may be either a type or function
      | token.Builtin -> {
        this.advance();

        match (this.token) {
          | token.Fun ->
            ast.TLFunction(
              this.parseFunctionDeclaration(startLoc, attributes, isPublic, true, false, false,
                false),
            )
          | token.Type ->
            ast.TLType (this.parseTypeDeclaration(startLoc, attributes, isPublic, true))
          | actual ->
            fatal(error.UnexpectedTokens { actual, expected: [token.Fun, token.Type] }, this.loc)
        }
      }
      | token -> fatal(error.MalformedToplevel { token }, this.loc)
    };
  }

  fun maybeParsePublic(): Bool =
    if (this.token == token.Pub) {
      this.advance();
      true
    } else {
      false
    }
  
  fun parseAttributes(): Vec<ast.Attribute> {
    val attributes: Vec<ast.Attribute> = [];

    while (this.token match token.At) {
      var startLoc = this.loc;
      this.advance();
      this.expect(token.LeftParen);

      val items: Vec<ast.AttributeItem> = [];

      while (this.token != token.RightParen) {
        val startLoc = this.loc;
        items.push(this.parseAttributeItem());

        match (this.token) {
          | token.RightParen -> ()
          | token.Comma -> this.advance()
          | _ -> this.expect(token.RightParen)
        }
      }

      this.advance();
      val loc = this.currentLoc(startLoc);
      val attribute = ast.Attribute { loc, items };
      attributes.push(attribute);
    }

    return attributes;
  }

  fun parseAttributeItem(): ast.AttributeItem {
    return ast.AttributeItem (this.parseIdentifier());
  }

  fun parseIdentifier(): ast.Identifier {
    match (this.token) {
      | token.Identifier (name) -> {
        val loc = this.loc;
        this.advance();
        return ast.Identifier { loc, name };
      }
      | actual -> {
        val error = error.UnexpectedToken { actual, expected: Some (token.Identifier ("")) };
        return fatal(error, this.loc);
      }
    }
  }

  fun parseScopedIdentifier(): ast.ScopedIdentifier {
    val startLoc = this.loc;

    val scopes: Vec<ast.Identifier> = [];
    var name = this.parseIdentifier();

    while (this.token == token.Period) {
      this.advance();
      scopes.push(name);
      name = this.parseIdentifier();
    }

    val loc = this.currentLoc(startLoc);

    return ast.ScopedIdentifier { loc, scopes, name };
  }

  /* 
   * ============================
   *        Declarations
   * ============================
   */

  fun parseFunctionDeclaration(
    startLoc: Loc,
    attributes: Vec<ast.Attribute>,
    isPublic: Bool,
    isBuiltin: Bool,
    isOverride: Bool,
    isStatic: Bool,
    inTrait: Bool,
  ): ast.FunctionDeclaration {
    this.expect(token.Fun);

    val name = this.parseIdentifier();
    val typeParams = this.parseTypeParameters();

    val (params, return_) = this.parseFunctionSignature();

    // Parse function body
    val body = match (this.token) {
      // Builtin functions never have a body, so mark body as function signature
      | _ when isBuiltin -> ast.FBSignature
      // Function bodies can be a block or expression
      | token.LeftBrace -> ast.FBBlock (this.parseBlock())
      | token.Equals -> {
        this.advance();
        ast.FBExpression (this.parseExpression())
      }
      // Methods in trait may have a body, otherwise they are method signatures
      | _ when inTrait -> ast.FBSignature
      | token -> fatal(error.MalformedFunctionBody { token }, this.loc)
    };

    val loc = this.currentLoc(startLoc);

    return ast.FunctionDeclaration { loc, name, params, body, return_, typeParams, attributes,
      isPublic, isBuiltin, isStatic, isOverride };
  }

  fun parseFunctionSignature(): (Vec<ast.FunctionParam>, Option<ast.Type>) {
    // Parse function parameters
    val params: Vec<ast.FunctionParam> = [];
    this.expect(token.LeftParen);

    while (this.token != token.RightParen) {
      val startLoc = this.loc;
      val name = this.parseIdentifier();
      this.expect(token.Colon);
      val annot = this.parseType();

      val loc = this.currentLoc(startLoc);
      params.push(ast.FunctionParam { loc, name, annot });

      match (this.token) {
        | token.RightParen -> ()
        | token.Comma -> this.advance()
        | _ -> this.expect(token.RightParen)
      }
    }

    this.advance();

    // Parse optional return type
    val return_ = match (this.token) {
      | token.Colon -> {
        this.advance();
        Some (this.parseType())
      }
      | _ -> None
    };

    return (params, return_);
  }

  fun parseAnonymousFunctionSignature(): (Vec<ast.AnonymousFunctionParam>, Option<ast.Type>) {
    // Parse function parameters
    val params: Vec<ast.AnonymousFunctionParam> = [];
    this.expect(token.LeftParen);

    while (this.token != token.RightParen) {
      val startLoc = this.loc;
      val name = this.parseIdentifier();

      val annot = match (this.token) {
        | token.Colon -> {
          this.advance();
          Some (this.parseType())
        }
        | _ -> None
      };

      val loc = this.currentLoc(startLoc);
      params.push(ast.AnonymousFunctionParam { loc, name, annot });

      match (this.token) {
        | token.RightParen -> ()
        | token.Comma -> this.advance()
        | _ -> this.expect(token.RightParen)
      }
    }

    this.advance();

    // Parse optional return type
    val return_ = match (this.token) {
      | token.Colon -> {
        this.advance();
        Some (this.parseType())
      }
      | _ -> None
    };

    return (params, return_);
  }

  fun parseVariableDeclaration(
    startLoc: Loc,
    isToplevel: Bool,
    attributes: Vec<ast.Attribute>,
    isPublic: Bool,
  ): ast.VariableDeclaration {
    val kind = if (this.token == token.Val) {
      ast.Immutable
    } else {
      ast.Mutable
    };

    this.advance();

    val pattern = this.parsePattern(true);
    val annot = if (this.token == token.Colon) {
      this.advance();
      Some (this.parseType())
    } else {
      None
    };

    this.expect(token.Equals);
    val init = this.parseExpression();
    if (!isToplevel) {
      this.expect(token.Semicolon);
    }

    val loc = this.currentLoc(startLoc);

    return ast.VariableDeclaration { loc, kind, pattern, annot, init, attributes, isPublic };
  }

  fun parseTypeDeclaration(
    startLoc: Loc,
    attributes: Vec<ast.Attribute>,
    isPublic: Bool,
    isBuiltin: Bool,
  ): ast.TypeDeclaration {
    this.expect(token.Type);

    // Parse type alias if alias keyword is encountered
    if (this.token == token.Alias) {
      this.advance();

      val name = this.parseIdentifier();
      val typeParams = this.parseTypeParameters();
      this.expect(token.Equals);
      val ty = this.parseType();
      val loc = this.currentLoc(startLoc);

      return ast.TypeDeclaration
        { loc, name, typeParams, decl: ast.TDAlias (ty), attributes, isPublic };
    }

    val nameStartLoc = this.loc;
    val name = this.parseIdentifier();
    val typeParams = this.parseTypeParameters();

    // Builtin types only have a name and type parameters
    if (isBuiltin) {
      val loc = this.currentLoc(startLoc);
      return ast.TypeDeclaration
        { loc, name, typeParams, decl: ast.TDBuiltin, attributes, isPublic };
    }

    return match (this.token) {
      // A left paren following the name signifies a single tuple variant
      | token.LeftParen -> {
        val tuple = this.parseTupleDeclaration(name, nameStartLoc);
        val loc = this.currentLoc(startLoc);

        return ast.TypeDeclaration
          { loc, name, typeParams, decl: ast.TDTuple (tuple), attributes, isPublic };
      }
      // A left brace following the name signifies a single record variant
      | token.LeftBrace -> {
        val record = this.parseRecordDeclaration(name, nameStartLoc, false);
        val loc = this.currentLoc(startLoc);

        return ast.TypeDeclaration
          { loc, name, typeParams, decl: ast.TDRecord (record), attributes, isPublic };
      }
      // Otherwise there are multiple variants in this declaration
      | token.Equals -> {
        this.advance();
        val variants = this.parseVariants();
        val loc = this.currentLoc(startLoc);

        if (variants.size == 1) {
          fatal(error.SingleVariant, loc);
        }

        return ast.TypeDeclaration
          { loc, name, typeParams, decl: ast.TDVariant (variants), attributes, isPublic };
      }
      | _ -> fatal(error.MalformedTypeDeclaration { token: this.token }, this.loc)
    };
  }

  fun parseVariants(): Vec<ast.VariantDeclaration> {
    // Variants may optionally have a leading pipe
    match (this.token) {
      | token.Pipe -> this.advance()
      | _ -> ()
    }

    val variants: Vec<ast.VariantDeclaration> = [];
    while (true) {
      val startLoc = this.loc;
      val name = this.parseIdentifier();

      val variant = match (this.token) {
        | token.LeftParen -> ast.TupleVariant (this.parseTupleDeclaration(name, startLoc))
        | token.LeftBrace -> ast.RecordVariant (this.parseRecordDeclaration(name, startLoc, true))
        | _ -> ast.EnumVariant (name)
      };

      variants.push(variant);

      match (this.token) {
        | token.Pipe -> this.advance()
        | _ -> break
      }
    }

    return variants;
  }

  fun parseTupleDeclaration(name: ast.Identifier, startLoc: Loc): ast.TupleDeclaration {
    this.expect(token.LeftParen);

    val elements: Vec<ast.Type> = [];
    while (this.token != token.RightParen) {
      elements.push(this.parseType());
      match (this.token) {
        | token.RightParen -> ()
        | token.Comma -> this.advance()
        | _ -> this.expect(token.RightParen)
      }
    }

    this.advance();
    val loc = this.currentLoc(startLoc);

    if (elements.size == 0) {
      fatal(error.EmptyTuple, loc);
    }

    return ast.TupleDeclaration { loc, name, elements };
  }

  fun parseRecordDeclaration(name: ast.Identifier, startLoc: Loc, isVariant: Bool): ast.RecordDeclaration {
    this.expect(token.LeftBrace);

    val fields: Vec<ast.RecordDeclarationField> = [];
    while (this.token != token.RightBrace) {
      val startLoc = this.loc;

      val isPublic = if (!isVariant) {
        this.maybeParsePublic()
      } else {
        false
      };
      
      val isMutable = if (!isVariant && this.token == token.Var) {
        this.advance();
        true
      } else {
        false
      };

      val name = this.parseIdentifier();
      this.expect(token.Colon);
      val type_ = this.parseType();
      val loc = this.currentLoc(startLoc);

      fields.push(ast.RecordDeclarationField { loc, name, type_, isPublic, isMutable });

      match (this.token) {
        | token.RightBrace -> ()
        | token.Comma -> this.advance()
        | _ -> this.expect(token.RightBrace)
      }
    }

    this.advance();
    val loc = this.currentLoc(startLoc);

    if (fields.size == 0) {
      fatal(error.EmptyRecord, loc);
    }

    return ast.RecordDeclaration { loc, name, fields };
  }

  fun parseTraitDeclaration(
    kind: ast.TraitDeclarationKind,
    startLoc: Loc,
    attributes: Vec<ast.Attribute>,
    isPublic: Bool,
  ): ast.TraitDeclaration {
    this.advance();

    val inTrait = match (kind) {
      | ast.TKTrait -> true
      | ast.TKMethods -> false
    };

    // Parse trait declaration name and type parameters
    val name = this.parseIdentifier();
    val typeParams = this.parseTypeParameters();

    this.expect(token.LeftBrace);

    // Trait declaration body starts with list of implemented traits
    val implemented: Vec<ast.IdentifierType> = [];
    while (true) {
      match (this.token, kind) {
        | (token.Implements, ast.TKMethods)
        | (token.Extends, ast.TKTrait) -> {
          val startLoc = this.loc;
          this.advance();

          // Parse implemented trait and its type arguments
          val name = this.parseScopedIdentifier();
          val typeArgs = this.parseTypeArgs();
          val loc = this.currentLoc(startLoc);

          implemented.push(ast.IdentifierType { loc, name, typeArgs });
        }
        | _ -> break
      }
    }

    // Remaining items in body are method declarations
    val methods_: Vec<ast.FunctionDeclaration> = [];
    while (this.token != token.RightBrace) {
      val startLoc = this.loc;

      val attributes = this.parseAttributes();
      val isPublic = this.maybeParsePublic();

      // Methods may optionally start with modifier keywords
      val isBuiltin = this.token == token.Builtin;
      if (isBuiltin) {
        this.advance();
      }

      val isOverride = this.token == token.Override;
      if (isOverride) {
        this.advance();
      }

      val isStatic = this.token == token.Static;
      if (isStatic) {
        this.advance();
      }

      if (this.token == token.Fun) {
        val method = this.parseFunctionDeclaration(
          startLoc, attributes, isPublic, isBuiltin, isOverride, isStatic, inTrait,
        );
        methods_.push(method);
      } else {
        fatal(error.MalformedMethodsItem { token: this.token }, this.loc);
      }
    }

    this.advance();
    val loc = this.currentLoc(startLoc);

    return ast.TraitDeclaration
      { loc, kind, name, typeParams, implemented, methods_, attributes, isPublic };
  }

  fun parseTypeParameters(): Vec<ast.TypeParameter> {
    if (this.token != token.LessThan) {
      return [];
    }

    this.advance();

    // List of type params must be nonempty
    if (this.token == token.GreaterThan) {
      this.expect(token.Identifier (""));
      return [];
    }

    val typeParams: Vec<ast.TypeParameter> = [];
    while (this.token != token.GreaterThan) {
      val startLoc = this.loc;
      val name = this.parseIdentifier();

      // Parse type parameter bounds if any are provided
      val bounds = match (this.token) {
        | token.Colon -> {
          this.advance();

          // Bounds are separated with a potentially trailing ampersand
          val bounds = [this.parseIdentifierType()];
          while (this.token == token.Ampersand) {
            this.advance();
            match (this.token) {
              | token.Comma
              | token.GreaterThan -> break
              | _ -> bounds.push(this.parseIdentifierType())
            }
          }

          bounds
        }
        | _ -> []
      };

      val loc = this.currentLoc(startLoc);
      typeParams.push(ast.TypeParameter { loc, name, bounds });

      match (this.token) {
        | token.GreaterThan -> ()
        | token.Comma -> this.advance()
        | _ -> this.expect(token.GreaterThan)
      }
    }

    this.advance();

    return typeParams;
  }

  /* 
   * ============================
   *        Statements
   * ============================
   */

  fun parseStatement(): ast.Statement {
    return match (this.token) {
      | token.LeftBrace -> ast.SBlock (this.parseBlock())
      | token.Val
      | token.Var ->
        ast.SVariableDeclaration (this.parseVariableDeclaration(this.loc, false, [], false))
      | token.If -> ast.SIf (this.parseIf())
      | token.Match -> ast.SMatch (this.parseMatch(false))
      | token.While -> ast.SWhile (this.parseWhile())
      | token.For -> ast.SFor (this.parseFor())
      | token.Return -> ast.SReturn (this.parseReturn(false))
      | token.Break -> ast.SBreak (this.parseBreak(false))
      | token.Continue -> ast.SContinue (this.parseContinue(false))
      | _ -> this.parseAssignmentOrExpressionStatement()
    };
  }

  fun parseBlock(): ast.Block {
    val startLoc = this.loc;
    this.expect(token.LeftBrace);

    val statements: Vec<ast.Statement> = [];
    while (this.token != token.RightBrace) {
      statements.push(this.parseStatement());
    }

    this.advance();
    val loc = this.currentLoc(startLoc);

    return ast.Block { loc, statements };
  }

  fun parseAssignmentOrExpressionStatement(): ast.Statement {
    val startLoc = this.loc;
    val expr = this.parseExpression();

    val op = match (this.token) {
      // If followed by an equals or equals operation this is an assignment statement
      | token.Equals -> None
      | token.PlusEquals -> Some (ast.AssignAdd)
      | token.MinusEquals -> Some (ast.AssignSubtract)
      | token.MultiplyEquals -> Some (ast.AssignMultiply)
      | token.DivideEquals -> Some (ast.AssignDivide)
      | token.PercentEquals -> Some (ast.AssignRemainder)
      | token.AmpersandEquals -> Some (ast.AssignBitwiseAnd)
      | token.PipeEquals -> Some (ast.AssignBitwiseOr)
      | token.CaretEquals -> Some (ast.AssignBitwiseXor)
      | token.LeftShiftEquals -> Some (ast.AssignLeftShift)
      | token.ArithmeticRightShiftEquals -> Some (ast.AssignArithmeticRightShift)
      | token.LogicalRightShiftEquals -> Some (ast.AssignLogicalRightShift)
      // If the expression is not followed by an equals then it must be an expression statement
      | _ -> {

        // An expression statement must be terminated by a semicolon unless it is the last
        // statement in a block, in which case it is the value of the block.
        val isValue = if (this.token == token.RightBrace) {
          true
        } else {
          this.expect(token.Semicolon);
          false
        };

        val loc = this.currentLoc(startLoc);

        return ast.SExpression (ast.ExpressionStatement { loc, expr, isValue });
      }
    };

    // First expression is actually the lvalue for an assignment statement
    val lvalue = if (op.isNone()) {
      this.reparseExpressionAsAssignmentLvalue(expr)
    } else {
      this.reparseExpressionAsAssignmentOpLvalue(expr)
    };

    // Parse right hand side of assignment
    this.advance();
    val expr = this.parseExpression();
    this.expect(token.Semicolon);
    val loc = this.currentLoc(startLoc);

    return ast.SAssignment (ast.Assignment { loc, op, lvalue, expr });
  }

  fun reparseExpressionAsAssignmentLvalue(expr: ast.Expression): ast.AssignmentLvalue =
    match (expr) {
      | ast.EIndexedAccess _
      | ast.ENamedAccess _ -> {
        this.assertExpressionIsLvalueExpression(expr);
        ast.ALExpression (expr)
      }
      | _ -> ast.ALPattern (this.reparseExpressionAsLvaluePattern(expr))
    }
  
  fun reparseExpressionAsAssignmentOpLvalue(expr: ast.Expression): ast.AssignmentLvalue =
    match (expr) {
      | ast.EIdentifier (ast.Identifier { loc, name: "_" }) ->
        fatal(error.InvalidAssignmentPattern, loc)
      | ast.EIdentifier _
      | ast.EScopedIdentifier _
      | ast.EIndexedAccess _
      | ast.ENamedAccess _ -> this.reparseExpressionAsAssignmentLvalue(expr)
      | _ -> fatal(error.InvalidAssignmentPattern, ast.utils.expressionLoc(expr))
    }
  
  fun assertExpressionIsLvalueExpression(expr: ast.Expression) =
    match (expr) {
      | ast.EIdentifier _ -> ()
      | ast.ENamedAccess (ast.NamedAccess { target, ... })
      | ast.EIndexedAccess (ast.IndexedAccess { target, ... }) ->
        this.assertExpressionIsLvalueExpression(target)
      | _ -> fatal(error.InvalidAssignmentPattern, ast.utils.expressionLoc(expr))
    }
  
  fun reparseExpressionAsLvaluePattern(expr: ast.Expression): ast.Pattern =
    match (expr) {
      | ast.EIdentifier (ast.Identifier { loc, name: "_" }) -> ast.PWildcard (loc)
      | ast.EIdentifier (ident) -> ast.PIdentifier (ast.utils.identifierToScopedIdentifier(ident))
      | ast.EScopedIdentifier (ident) -> ast.PIdentifier (ident)
      | ast.EBinaryOperation (
            ast.BinaryOperation { loc, op: ast.BinaryBitwiseOr, left, right },
          ) -> {
        val left = this.reparseExpressionAsLvaluePattern(left);
        val right = this.reparseExpressionAsLvaluePattern(right);

        ast.POr (ast.OrPattern { loc, left, right })
      }
      | ast.ETuple (ast.TupleExpression { loc, elements }) -> {
        val patternElements: Vec<ast.Pattern> = [];
        for (element in elements) {
          patternElements.push(this.reparseExpressionAsLvaluePattern(element));
        }

        ast.PTuple (ast.TuplePattern { loc, name: None, elements: patternElements })
      }
      | ast.ECall (ast.Call { loc, func, args }) -> {
        val name = this.reparseNameParts(func);
        val elements: Vec<ast.Pattern> = [];
        for (arg in args) {
          elements.push(this.reparseExpressionAsLvaluePattern(arg));
        }

        ast.PTuple (ast.TuplePattern { loc, name: Some (name), elements })
      }
      | ast.ERecord (ast.RecordExpression { loc, name, fields, rest }) -> {
        val name = this.reparseNameParts(name);

        // Reparse record fields
        val fieldPatterns: Vec<ast.RecordPatternField> = [];
        for (ast.RecordExpressionField { loc, name, value } in fields) {
          val field = match (value) {
            // Field shorthand can be converted
            | None -> {
              val value = ast.PIdentifier (ast.utils.identifierToScopedIdentifier(name));
              ast.RecordPatternField { loc, name: None, value }
            }
            // Explicit value must be converted to a pattern
            | Some (value) -> {
              val value = this.reparseExpressionAsLvaluePattern(value);
              ast.RecordPatternField { loc, name: Some (name), value }
            }
          };

          fieldPatterns.push(field);
        }

        ast.PRecord (ast.RecordPattern { loc, name, fields: fieldPatterns, rest: rest.isSome() })
      }
      | _ -> fatal(error.InvalidAssignmentPattern, ast.utils.expressionLoc(expr))
    }

    fun reparseNameParts(expr: ast.Expression): ast.ScopedIdentifier {
      // Collect all identifier parts in nested named access chain
      val parts: Vec<ast.Identifier> = [];
      var current = expr;

      while (true) {
        match (current) {
          | ast.EIdentifier (ident) -> {
            parts.push(ident);
            break;
          }
          | ast.ENamedAccess (ast.NamedAccess { target, name, ... }) -> {
            parts.push(name);
            current = target;
          }
          | _ -> fatal(error.InvalidAssignmentPattern, ast.utils.expressionLoc(current))
        }
      }

      // Identifier parts are reversed, so first part and scopes are remaining parts (reversed)
      val name = parts[0];
      val scopes: Vec<ast.Identifier> = [];
      for (i in (parts.size - 1).stepDownTo(0, 1)) {
        scopes.push(parts[i]);
      }

      val loc = if (scopes.size == 0) {
        name.loc
      } else {
        Loc.between(scopes[0].loc, name.loc)
      };

      return ast.ScopedIdentifier { loc, name, scopes };
    }

  fun parseMatch(isExpression: Bool): ast.Match {
    val startLoc = this.loc;
    this.expect(token.Match);

    // Parse nonempty arguments list
    this.expect(token.LeftParen);
    val args: Vec<ast.Expression> = [];

    while (true) {
      args.push(this.parseExpression());

      // Args are separated by commas and end at right paren, with optional trailing comma
      match (this.token) {
        | token.RightParen -> break
        | token.Comma -> {
          this.advance();

          // May be a trailing comma, finish args if so
          if (this.token == token.RightParen) {
            break;
          }
        }
        | _ -> this.expect(token.RightParen)
      }
    }

    this.expect(token.RightParen);

    // Parse match cases
    this.expect(token.LeftBrace);
    this.enterMatch();

    // Pipe for first case is optional
    if (this.token == token.Pipe) {
      this.advance();
    }

    val cases: Vec<ast.MatchCase> = [];
    while (true) {
      cases.push(this.parseMatchCase(isExpression));

      // A pipe following a match case means another case follows, otherwise must be end of body
      match (this.token) {
        | token.RightBrace -> break
        | token.Pipe -> this.advance()
        | _ -> this.expect(token.RightBrace)
      }
    }

    this.expect(token.RightBrace);
    this.exitMatch();

    val loc = this.currentLoc(startLoc);

    return ast.Match { loc, args, cases };
  }

  fun parseIf(): ast.If {
    val startLoc = this.loc;

    // Parse if keyword and parenthesized test
    this.expect(token.If);
    this.expect(token.LeftParen);
    val test = this.parseTest();
    this.expect(token.RightParen);

    // Consequent must always be a block
    val conseq = this.parseBlock();

    // Altern may be a single else block, an else if statement, or may not exist at all
    val altern = if (this.token == token.Else) {
      this.advance();
      if (this.token == token.If) {
        ast.ElseIf (this.parseIf())
      } else {
        ast.Else (this.parseBlock())
      }
    } else {
      ast.NoAltern
    };

    val loc = this.currentLoc(startLoc);

    return ast.If { loc, test, conseq, altern };
  }

  fun parseTest(): ast.Test {
    val startLoc = this.loc;
    val expr = this.parseExpression();

    if (this.token == token.Match) {
      this.advance();
      val pattern = this.parsePattern(false);

      val guard = if (this.token == token.When) {
        this.advance();
        Some (this.parseExpression())
      } else {
        None
      };

      val loc = this.currentLoc(startLoc);

      return ast.TMatch (ast.MatchTest { loc, expr, pattern, guard });
    } else {
      return ast.TExpression (expr);
    }
  }

  fun parseMatchCase(isExpression: Bool): ast.MatchCase {
    val startLoc = this.loc;

    // Parse pattern with optional match guard
    val pattern = this.parsePattern(false);
    val guard = if (this.token == token.When) {
      this.advance();
      Some (this.parseExpression())
    } else {
      None
    };

    this.expect(token.Arrow);

    // Parse body of match case. Only certain statements are allowed as body of match case.
    val body = match (this.token) {
      | token.LeftBrace -> ast.MCStatement (ast.SBlock (this.parseBlock()))
      | token.While -> ast.MCStatement (ast.SWhile (this.parseWhile()))
      | token.For -> ast.MCStatement (ast.SFor (this.parseFor()))
      | token.Return -> ast.MCStatement (ast.SReturn (this.parseReturn(true)))
      | token.Break -> ast.MCStatement (ast.SBreak (this.parseBreak(true)))
      | token.Continue -> ast.MCStatement (ast.SContinue (this.parseContinue(true)))
      | token.If -> {
        val if_ = this.parseIf();
        if (isExpression) {
          ast.MCExpression (ast.EIf (if_))
        } else {
          ast.MCStatement (ast.SIf (if_))
        }
      }
      | token.Match -> {
        val match_ = this.parseMatch(isExpression);
        if (isExpression) {
          ast.MCExpression (ast.EMatch (match_))
        } else {
          ast.MCStatement (ast.SMatch (match_))
        }
      }
      | _ -> ast.MCExpression (this.parseExpression())
    };

    val loc = this.currentLoc(startLoc);

    return ast.MatchCase { loc, pattern, guard, body };
  }

  fun parseWhile(): ast.While {
    val startLoc = this.loc;
    this.expect(token.While);

    // Parse test and block body
    this.expect(token.LeftParen);
    val test = this.parseTest();
    this.expect(token.RightParen);
    val body = this.parseBlock();

    val loc = this.currentLoc(startLoc);

    return ast.While { loc, test, body };
  }

  fun parseFor(): ast.For {
    val startLoc = this.loc;
    this.expect(token.For);
    this.expect(token.LeftParen);

    // Parse pattern and its optional annotation
    val pattern = this.parsePattern(true);
    val annot = if (this.token == token.Colon) {
      this.advance();
      Some (this.parseType())
    } else {
      None
    };

    this.expect(token.In);
    val iterator = this.parseExpression();
    this.expect(token.RightParen);

    val body = this.parseBlock();
    val loc = this.currentLoc(startLoc);

    return ast.For { loc, pattern, annot, iterator, body };
  }

  fun parseReturn(inMatchCase: Bool): ast.Return {
    val startLoc = this.loc;
    this.expect(token.Return);

    // Parse return argument
    val arg = match (this.token) {
      | token.Semicolon -> None
      /* Handle the following cases:
         match (x) {
           | a -> return
         }

         match (x) {
           | a -> return
           | b -> c
         } */
      | token.Pipe
      | token.RightBrace when inMatchCase -> None
      | _ -> Some (this.parseExpression())
    };

    if (!inMatchCase) {
      this.expect(token.Semicolon);
    }

    val loc = this.currentLoc(startLoc);

    return ast.Return { loc, arg };
  }

  fun parseBreak(inMatchCase: Bool): ast.Break {
    val startLoc = this.loc;
    this.expect(token.Break);
    if (!inMatchCase) {
      this.expect(token.Semicolon);
    }

    val loc = this.currentLoc(startLoc);

    return ast.Break { loc };
  }

  fun parseContinue(inMatchCase: Bool): ast.Continue {
    val startLoc = this.loc;
    this.expect(token.Continue);
    if (!inMatchCase) {
      this.expect(token.Semicolon);
    }

    val loc = this.currentLoc(startLoc);

    return ast.Continue { loc };
  }

  /* 
   * ============================
   *        Expressions
   * ============================
   */

  fun parseExpression(): ast.Expression {
    return this.parseExpressionWithPrecedence(precedence.Toplevel);
  }

  fun parseExpressionWithPrecedence(leftPrecedence: Precedence): ast.Expression {
    val startLoc = this.loc;

    var expr = this.parseExpressionPrefix();
    while (true) {
      expr = match (this.token) {
        | token.LeftParen when leftPrecedence.isWeakerThan(precedence.Call) ->
          ast.ECall (this.parseCall(expr, startLoc))
        | token.LeftBrace when leftPrecedence.isWeakerThan(precedence.Call) ->
          ast.ERecord (this.parseRecordExpression(expr, startLoc))
        | token.Period when leftPrecedence.isWeakerThan(precedence.Access) ->
          ast.ENamedAccess (this.parseNamedAccess(expr, startLoc))
        | token.LeftBracket when leftPrecedence.isWeakerThan(precedence.Access) ->
          ast.EIndexedAccess (this.parseIndexedAccess(expr, startLoc))
        | token.Plus
        | token.Minus when leftPrecedence.isWeakerThan(precedence.Addition) ->
          ast.EBinaryOperation (this.parseBinaryOperation(expr, startLoc))
        | token.Multiply
        | token.Divide
        | token.Percent when leftPrecedence.isWeakerThan(precedence.Multiplication) ->
          ast.EBinaryOperation (this.parseBinaryOperation(expr, startLoc))
        | token.Ampersand when leftPrecedence.isWeakerThan(precedence.BitwiseAnd) ->
          ast.EBinaryOperation (this.parseBinaryOperation(expr, startLoc))
        | token.Pipe
            when leftPrecedence.isWeakerThan(precedence.BitwiseOr) && this.canUseBitwiseOr() ->
          ast.EBinaryOperation (this.parseBinaryOperation(expr, startLoc))
        | token.Caret when leftPrecedence.isWeakerThan(precedence.BitwiseXor) ->
          ast.EBinaryOperation (this.parseBinaryOperation(expr, startLoc))
        | token.LessThanOrEqual
        | token.GreaterThanOrEqual when leftPrecedence.isWeakerThan(precedence.Comparison) ->
          ast.EBinaryOperation (this.parseBinaryOperation(expr, startLoc))
        | token.DoubleEquals
        | token.NotEquals when leftPrecedence.isWeakerThan(precedence.Equality) ->
          ast.EBinaryOperation (this.parseBinaryOperation(expr, startLoc))
        | token.LogicalAnd when leftPrecedence.isWeakerThan(precedence.LogicalAnd) ->
          ast.ELogicalAnd (this.parseLogicalAnd(expr, startLoc))
        | token.LogicalOr when leftPrecedence.isWeakerThan(precedence.LogicalOr) ->
          ast.ELogicalOr (this.parseLogicalOr(expr, startLoc))
        | token.Question when leftPrecedence.isWeakerThan(precedence.Unwrap) ->
          ast.EUnwrap (this.parseUnwrap(expr, startLoc))
        // A less than can be the start of a comparison or left shift
        | token.LessThan -> {
          // Two adjacent less thans are a left shift
          val TokenResult { token: secondToken, loc: secondLoc } = this.peek();
          if (secondToken == token.LessThan &&
              leftPrecedence.isWeakerThan(precedence.BitwiseShift) &&
              this.loc.isAdjacentTo(secondLoc)) {
            ast.EBinaryOperation(this.parseLeftShift(expr, startLoc))
          } else if (leftPrecedence.isWeakerThan(precedence.Comparison)) {
            // Otherwise it is a les than comparison
            ast.EBinaryOperation(this.parseLessThan(expr, startLoc))
          } else {
            break;
          }
        }
        // A greater than can be the start of a comparison or right shift
        | token.GreaterThan -> {
          // Two adjacent greater thans must be a right shift
          val TokenResult { token: secondToken, loc: secondLoc } = this.peek();
          if (secondToken == token.GreaterThan &&
              leftPrecedence.isWeakerThan(precedence.BitwiseShift) &&
              this.loc.isAdjacentTo(secondLoc)) {
            this.expect(token.GreaterThan);
            this.expect(token.GreaterThan);

            // A third adjacent greater than is a logical right shift, otherwise arithmetic
            if (this.token == token.GreaterThan && secondLoc.isAdjacentTo(this.loc)) {
              ast.EBinaryOperation(this.parseLogicalRightShift(expr, startLoc))
            } else {
              ast.EBinaryOperation(this.parseArithmeticRightShift(expr, startLoc))
            }
          } else if (leftPrecedence.isWeakerThan(precedence.Comparison)) {
            // Otherwise it is a greater than comparison
            ast.EBinaryOperation(this.parseGreaterThan(expr, startLoc))
          } else {
            break;
          }
        }
        | _ -> break
      };
    }

    return expr;
  }

  fun parseExpressionPrefix(): ast.Expression {
    return match (this.token) {
      | token.Identifier _ -> ast.EIdentifier (this.parseIdentifier())
      | token.Wildcard -> {
        val loc = this.loc;
        this.advance();
        ast.EIdentifier (ast.Identifier { loc, name: "_" })
      }
      | token.LeftParen -> this.parseParenthesizedExpression()
      | token.IntLiteral { raw, base } -> {
        val loc = this.loc;
        this.advance();
        ast.EIntLiteral (ast.IntLiteral { loc, raw, base })
      }
      | token.FloatLiteral { raw } -> {
        val loc = this.loc;
        this.advance();
        ast.EFloatLiteral (ast.FloatLiteral { loc, raw })
      }
      | token.BoolLiteral (value) -> {
        val loc = this.loc;
        this.advance();
        ast.EBoolLiteral (ast.BoolLiteral { loc, value })
      }
      | token.StringLiteral (value) -> {
        val loc = this.loc;
        this.advance();
        ast.EStringLiteral (ast.StringLiteral { loc, value })
      }
      | token.CharLiteral (value) -> {
        val loc = this.loc;
        this.advance();
        ast.ECharLiteral (ast.CharLiteral { loc, value })
      }
      | token.InterpolatedString { string, isEnd } ->
        ast.EInterpolatedString (this.parseInterpolatedString(string, isEnd))
      | token.If -> ast.EIf (this.parseIf())
      | token.Match -> ast.EMatch (this.parseMatch(true))
      | token.Plus -> ast.EUnaryOperation (this.parseUnaryPlus())
      | token.Minus -> this.parseUnaryMinusOrNegativeIntLiteral()
      | token.Bang -> ast.EUnaryOperation (this.parseUnaryNot())
      | token.Fn -> ast.EAnonymousFunction (this.parseAnonymousFunction())
      | token.LeftBracket -> ast.EVecLiteral (this.parseVecLiteral())
      | token.LeftBrace -> ast.EMapLiteral (this.parseMapLiteral())
      | token.SetOpen -> ast.ESetLiteral (this.parseSetLiteral())
      | actual -> fatal(error.UnexpectedToken { actual, expected: None }, this.loc)
    };
  }

  fun parseParenthesizedExpression(): ast.Expression {
    val startLoc = this.loc;
    this.expect(token.LeftParen);

    // A set of empty parens is a unit literal
    if (this.token == token.RightParen) {
      this.advance();
      val loc = this.currentLoc(startLoc);

      return ast.EUnitLiteral (ast.UnitLiteral { loc });
    }

    val expr = this.parseExpression();
    return match (this.token) {
      // A colon following an expression represents the start of a type cast `(expr: ty)`
      | token.Colon -> {
        this.advance();
        val type_ = this.parseType();
        this.expect(token.RightParen);
        val loc = this.currentLoc(startLoc);

        ast.ETypeCast (ast.TypeCast { loc, expr, type_ })
      }
      // A colon following an expression represents a tuple expression
      | token.Comma -> {
        val commaLoc = this.loc;
        this.advance();

        // Error if this would be parsed as a single element tuple with a trailing comma
        if (this.token == token.RightParen) {
          val error = error.UnexpectedToken {
            actual: token.Comma,
            expected: Some (token.RightParen),
          };
          fatal(error, commaLoc);
        }

        // Parse elements of tuple expression
        val elements = [expr]; 
        while (this.token != token.RightParen) {
          elements.push(this.parseExpression());
          match (this.token) {
            | token.RightParen -> ()
            | token.Comma -> this.advance()
            | _ -> this.expect(token.RightParen)
          }
        }

        this.advance();
        val loc = this.currentLoc(startLoc);

        ast.ETuple (ast.TupleExpression { loc, elements })
      }
      // Otherwise this must be a single parenthesized expression
      | _ -> {
        this.expect(token.RightParen);
        expr
      }
    };
  }

  fun parseCall(func: ast.Expression, startLoc: Loc): ast.Call {
    this.expect(token.LeftParen);

    val args: Vec<ast.Expression> = [];
    while (this.token != token.RightParen) {
      args.push(this.parseExpression());

      match (this.token) {
        | token.RightParen -> ()
        | token.Comma -> this.advance()
        | _ -> this.expect(token.RightParen)
      }
    }

    this.advance();
    val loc = this.currentLoc(startLoc);

    return ast.Call { loc, func, args };
  }

  fun parseRecordExpression(name: ast.Expression, startLoc: Loc): ast.RecordExpression {
    this.expect(token.LeftBrace);

    var rest: Option<Loc> = None;
    val fields: Vec<ast.RecordExpressionField> = [];

    while (true) {
      match (this.token) {
        // Record ends with a right element
        | token.RightBrace -> {
          this.advance();
          break;
        }
        // `...` is a rest element, and must be last element in record
        | token.Period -> {
          val startLoc = this.loc;
          this.expect(token.Period);
          this.expect(token.Period);
          this.expect(token.Period);

          // Save loc of rest element
          val loc = this.currentLoc(startLoc);
          rest = Some (loc);

          // Rest can optionally be followed by a trailing comma, then the record must end
          if (this.token == token.Comma) {
            this.advance();
          }
          
          this.expect(token.RightBrace);
          break;
        }
        // An identifier is the start of a record field
        | token.Identifier _ -> {
          val startLoc = this.loc;
          val name = this.parseIdentifier();

          // A colon indicates this field has both a name and value
          val field = if (this.token == token.Colon) {
            this.advance();
            val value = this.parseExpression();
            val loc = this.currentLoc(startLoc);

            ast.RecordExpressionField { loc, name, value: Some (value) }
          } else {
            // Otherwise this is field shorthand with just a name
            val loc = this.currentLoc(startLoc);

            ast.RecordExpressionField { loc, name, value: None }
          };

          fields.push(field);

          // Optionally followed by a trailing comma
          match (this.token) {
            | token.RightBrace -> ()
            | token.Comma -> this.advance()
            | _ -> this.expect(token.RightBrace)
          }
        }
        | _ -> this.expect(token.RightParen)
      }
    }

    val loc = this.currentLoc(startLoc);

    if (fields.size == 0) {
      fatal(error.EmptyRecord, loc);
    }

    return ast.RecordExpression { loc, name, fields, rest };
  }

  fun parseNamedAccess(target: ast.Expression, startLoc: Loc): ast.NamedAccess {
    this.expect(token.Period);
    val name = this.parseIdentifier();
    val loc = this.currentLoc(startLoc);

    return ast.NamedAccess { loc, target, name };
  }

  fun parseIndexedAccess(target: ast.Expression, startLoc: Loc): ast.IndexedAccess {
    this.expect(token.LeftBracket);
    val index = this.parseExpression();
    this.expect(token.RightBracket);
    val loc = this.currentLoc(startLoc);

    return ast.IndexedAccess { loc, target, index };
  }

  fun parseUnaryPlus(): ast.UnaryOperation {
    val startLoc = this.loc;
    this.expect(token.Plus);
    val operand = this.parseExpressionWithPrecedence(precedence.Unary);
    val loc = this.currentLoc(startLoc);

    return ast.UnaryOperation { loc, op: ast.UnaryPlus, operand };
  }

  fun parseUnaryNot(): ast.UnaryOperation {
    val startLoc = this.loc;
    this.expect(token.Bang);
    val operand = this.parseExpressionWithPrecedence(precedence.Unary);
    val loc = this.currentLoc(startLoc);

    return ast.UnaryOperation { loc, op: ast.UnaryNot, operand };
  }

  fun parseAnonymousFunction(): ast.AnonymousFunction {
    val startLoc = this.loc;
    this.expect(token.Fn);

    val (params, return_) = this.parseAnonymousFunctionSignature();

    // Parse function body
    val body = match (this.token) {
      | token.LeftBrace -> ast.ABBlock (this.parseBlock())
      | token.Arrow -> {
        this.advance();
        ast.ABExpression (this.parseExpression())
      }
      | token -> fatal(error.MalformedFunctionBody { token }, this.loc)
    };

    val loc = this.currentLoc(startLoc);

    return ast.AnonymousFunction { loc, params, return_, body };
  }

  fun parseUnaryMinusOrNegativeIntLiteral(): ast.Expression {
    val startLoc = this.loc;
    this.expect(token.Minus);

    return match (this.token) { 
      // When a minus is followed by an int literal with no space between them, it is a negative
      // int literal.
      | token.IntLiteral { raw, base } when startLoc.isAdjacentTo(this.loc) -> {
        this.advance();
        val raw = `-${raw}`;
        val loc = this.currentLoc(startLoc);

        return ast.EIntLiteral (ast.IntLiteral { loc, raw, base });
      }
      // Otherwise this is a unary minus expression
      | _ -> {
        val operand = this.parseExpressionWithPrecedence(precedence.Unary);
        val loc = this.currentLoc(startLoc);

        return ast.EUnaryOperation (ast.UnaryOperation { loc, op: ast.UnaryMinus, operand });
      }
    };
  }

  fun parseBinaryOperation(left: ast.Expression, startLoc: Loc): ast.BinaryOperation {
    val (op, precedence) = match (this.token) {
      | token.Plus -> (ast.BinaryAdd, precedence.Addition)
      | token.Minus -> (ast.BinarySubtract, precedence.Addition)
      | token.Multiply -> (ast.BinaryMultiply, precedence.Multiplication)
      | token.Divide -> (ast.BinaryDivide, precedence.Multiplication)
      | token.Percent -> (ast.BinaryRemainder, precedence.Multiplication)
      | token.Ampersand -> (ast.BinaryBitwiseAnd, precedence.BitwiseAnd)
      | token.Pipe -> (ast.BinaryBitwiseOr, precedence.BitwiseOr)
      | token.Caret -> (ast.BinaryBitwiseXor, precedence.BitwiseXor)
      | token.DoubleEquals -> (ast.BinaryEqual, precedence.Equality)
      | token.NotEquals -> (ast.BinaryNotEqual, precedence.Equality)
      | token.LessThanOrEqual -> (ast.BinaryLessThanOrEqual, precedence.Comparison)
      | token.GreaterThanOrEqual -> (ast.BinaryGreaterThanOrEqual, precedence.Comparison)
      // Unreachable
      | _ -> abort()
    };

    this.advance();
    val right = this.parseExpressionWithPrecedence(precedence);
    val loc = this.currentLoc(startLoc);

    return ast.BinaryOperation { loc, op, left, right };
  }

  fun parseLogicalAnd(left: ast.Expression, startLoc: Loc): ast.LogicalAnd {
    this.expect(token.LogicalAnd);
    val right = this.parseExpressionWithPrecedence(precedence.LogicalAnd);
    val loc = this.currentLoc(startLoc);

    return ast.LogicalAnd { loc, left, right };
  }

  fun parseLogicalOr(left: ast.Expression, startLoc: Loc): ast.LogicalOr {
    this.expect(token.LogicalOr);
    val right = this.parseExpressionWithPrecedence(precedence.LogicalOr);
    val loc = this.currentLoc(startLoc);

    return ast.LogicalOr { loc, left, right };
  }

  fun parseLessThan(left: ast.Expression, startLoc: Loc): ast.BinaryOperation {
    this.expect(token.LessThan);
    val right = this.parseExpressionWithPrecedence(precedence.Comparison);
    val loc = this.currentLoc(startLoc);

    return ast.BinaryOperation { loc, op: ast.BinaryLessThan, left, right };
  }

  fun parseGreaterThan(left: ast.Expression, startLoc: Loc): ast.BinaryOperation {
    this.expect(token.GreaterThan);
    val right = this.parseExpressionWithPrecedence(precedence.Comparison);
    val loc = this.currentLoc(startLoc);

    return ast.BinaryOperation { loc, op: ast.BinaryGreaterThan, left, right };
  }

  fun parseLeftShift(left: ast.Expression, startLoc: Loc): ast.BinaryOperation {
    this.expect(token.LessThan);
    this.expect(token.LessThan);
    val right = this.parseExpressionWithPrecedence(precedence.BitwiseShift);
    val loc = this.currentLoc(startLoc);

    return ast.BinaryOperation { loc, op: ast.BinaryLeftShift, left, right };
  }

  fun parseArithmeticRightShift(left: ast.Expression, startLoc: Loc): ast.BinaryOperation {
    val right = this.parseExpressionWithPrecedence(precedence.BitwiseShift);
    val loc = this.currentLoc(startLoc);

    return ast.BinaryOperation { loc, op: ast.BinaryArithmeticRightShift, left, right };
  }

  fun parseLogicalRightShift(left: ast.Expression, startLoc: Loc): ast.BinaryOperation {
    this.expect(token.GreaterThan);
    val right = this.parseExpressionWithPrecedence(precedence.BitwiseShift);
    val loc = this.currentLoc(startLoc);

    return ast.BinaryOperation { loc, op: ast.BinaryLogicalRightShift, left, right };
  }

  fun parseUnwrap(operand: ast.Expression, startLoc: Loc): ast.Unwrap {
    this.expect(token.Question);
    val loc = this.currentLoc(startLoc);

    return ast.Unwrap { loc, operand };
  }

  fun parseVecLiteral(): ast.VecLiteral {
    val startLoc = this.loc;
    this.expect(token.LeftBracket);

    // Parse elements of vec literal
    val elements: Vec<ast.Expression> = [];
    while (this.token != token.RightBracket) {
      elements.push(this.parseExpression());
      match (this.token) {
        | token.RightBracket -> ()
        | token.Comma -> this.advance()
        | _ -> this.expect(token.RightBracket)
      }
    }

    this.advance();
    val loc = this.currentLoc(startLoc);

    return ast.VecLiteral { loc, elements };
  }

  fun parseMapLiteral(): ast.MapLiteral {
    val startLoc = this.loc;
    this.expect(token.LeftBrace);

    // Parse entries of map literal
    val entries: Vec<ast.MapLiteralEntry> = [];
    while (this.token != token.RightBrace) {
      // Parse key value pair separated by a colon
      val startLoc = this.loc;
      val key = this.parseExpression();
      this.expect(token.Colon);
      val value = this.parseExpression();
      val loc = this.currentLoc(startLoc);

      entries.push(ast.MapLiteralEntry { loc, key, value });

      match (this.token) {
        | token.RightBrace -> ()
        | token.Comma -> this.advance()
        | _ -> this.expect(token.RightBrace)
      }
    }

    this.advance();
    val loc = this.currentLoc(startLoc);

    return ast.MapLiteral { loc, entries };
  }

  fun parseSetLiteral(): ast.SetLiteral {
    val startLoc = this.loc;
    this.expect(token.SetOpen);

    // Parse elements of set literal
    val elements: Vec<ast.Expression> = [];
    while (this.token != token.SetClose) {
      elements.push(this.parseExpression());
      match (this.token) {
        | token.SetClose -> ()
        | token.Comma -> this.advance()
        | _ -> this.expect(token.SetClose)
      }
    }

    this.advance();
    val loc = this.currentLoc(startLoc);

    return ast.SetLiteral { loc, elements };
  }

  fun parseInterpolatedString(firstString: String, isSinglePart: Bool): ast.InterpolatedString {
    val startLoc = this.loc;
    val loc = startLoc;
    this.advance();

    if (isSinglePart) {
      return ast.InterpolatedString {
        loc,
        parts: [ast.IPString (ast.StringLiteral { loc, value: firstString })],
     };
    }

    // String parts are only included if they are nonempy, e.g. `${expr1}${expr2}` has two
    // expression parts and no string parts.
    val parts: Vec<ast.InterpolatedStringPart> = [];
    if (firstString.size != 0) {
      parts.push(ast.IPString (ast.StringLiteral { loc, value: firstString }));
    }

    while (true) {
      parts.push(ast.IPExpression (this.parseExpression()));

      // Enter interpolated string mode before call to `advance` within `expect`. This ensures the
      // token after the right brace is lexed as an interpolated string token.
      this.enterInterpolatedString();
      this.expect(token.RightBrace);
      
      match (this.token) {
        | token.InterpolatedString { string, isEnd } -> {
          this.exitInterpolatedString();
          val loc = this.loc;
          this.advance();

          if (string.size != 0) {
            parts.push(ast.IPString (ast.StringLiteral { loc, value: string }));
          }

          if (isEnd) {
            break;
          }
        }
        // Unreachable, interpolated string is always returned when parsing interpolated strings
        | _ -> break
      }
    }

    val loc = this.currentLoc(loc);

    return ast.InterpolatedString { loc, parts };
  }

  /* 
   * ============================
   *           Types
   * ============================
   */

  fun parseType(): ast.Type {
    return match(this.token) {
      | token.Identifier _ -> ast.TIdentifier (this.parseIdentifierType())
      | token.LeftParen -> this.parseParenthesizedType()
      | token.Trait -> ast.TTrait (this.parseTraitType())
      | token -> fatal(error.MalformedType { token }, this.loc)
    };
  }

  fun parseIdentifierType(): ast.IdentifierType {
    val startLoc = this.loc;
    val name = this.parseScopedIdentifier();
    val typeArgs = this.parseTypeArgs();
    val loc = this.currentLoc(startLoc);

    return ast.IdentifierType { loc, name, typeArgs };
  }

  fun parseParenthesizedType(): ast.Type {
    val startLoc = this.loc;
    this.advance();

    // Parse comma separated elements in parenthesized list
    val elements: Vec<ast.Type> = [];

    // If list is empty then must be a part of function type or else error on right paren
    if (this.token == token.RightParen) {
      val rightParenLoc = this.loc;
      this.advance();

      match (this.token) {
        | token.Arrow -> ()
        | _ ->
          fatal(error.UnexpectedToken { actual: token.RightParen, expected: None }, rightParenLoc)
      }
    } else {
      // Parse comma separated elements in list
      while (true) {
        elements.push(this.parseType());

        match (this.token) {
          // End of list with no trailing comma
          | token.RightParen -> {
            this.advance();
            break;
          }
          | token.Comma -> {
            val commaLoc = this.loc;
            this.advance();

            // End of list with trailing comma
            if (this.token == token.RightParen) {
              this.advance();

              // Single element with trailing comma, error if not part of a function type
              if (elements.size == 1 && this.token != token.Arrow) {
                val error = error.UnexpectedToken {
                  actual: token.Comma,
                  expected: Some (token.RightParen),
                };
                fatal(error, commaLoc);
              }

              break;
            }
          }
          | _ -> this.expect(token.RightParen)
        }
      }
    }

    // A parenthesized list followed by an arrow is a function type
    if (this.token == token.Arrow) {
      this.advance();
      val return_ = this.parseType();
      val loc = this.currentLoc(startLoc);

      return ast.TFunction (ast.FunctionType { loc, params: elements, return_ });
    }

    // A parenthesized list with one item is just a parenthesized type, otherwise it is a tuple type
    return if (elements.size == 1) {
      elements[0]
    } else {
      val loc = this.currentLoc(startLoc);
      ast.TTuple (ast.TupleType  { loc, elements })
    };
  }

  fun parseTraitType(): ast.TraitType {
    val startLoc = this.loc;
    this.advance();
    val trait_ = this.parseIdentifierType();
    val loc = this.currentLoc(startLoc);

    return ast.TraitType { loc, trait_ };
  }

  fun parseTypeArgs(): Vec<ast.Type> {
    if (this.token != token.LessThan) {
      return [];
    }

    this.advance();

    // List of type args must be nonempty
    if (this.token == token.GreaterThan) {
      this.expect(token.Identifier (""));
    }

    val typeArgs: Vec<ast.Type> = [];
    while (this.token != token.GreaterThan) {
      typeArgs.push(this.parseType());

      match (this.token) {
        | token.GreaterThan -> ()
        | token.Comma -> this.advance()
        | _ -> this.expect(token.GreaterThan)
      }
    }

    this.advance();

    return typeArgs;
  }

  /* 
   * ============================
   *          Patterns
   * ============================
   */

  fun parsePattern(isDecl: Bool): ast.Pattern {
    return this.parsePatternWithPrecedence(isDecl, precedence.Toplevel);
  }

  fun parsePatternWithPrecedence(isDecl: Bool, leftPrecedence: Precedence): ast.Pattern {
    val startLoc = this.loc;

    var pattern = this.parsePatternPrefix(isDecl);
    while (true) {
      pattern = match (this.token) {
        | token.Pipe when leftPrecedence.isWeakerThan(precedence.BitwiseOr) -> {
          this.advance();
          val right = this.parsePatternWithPrecedence(isDecl, precedence.BitwiseOr);
          val loc = this.currentLoc(startLoc);

          ast.POr (ast.OrPattern { loc, left: pattern, right })
        }
        | token.As -> {
          this.advance();
          val name = this.parseIdentifier();
          val loc = this.currentLoc(startLoc);

          ast.PBinding (ast.BindingPattern { loc, pattern, name })
        }
        | _ -> break    
      };
    }

    return pattern;
  }

  fun parsePatternPrefix(isDecl: Bool): ast.Pattern {
    return match (this.token) {
      | token.Wildcard -> {
        val loc = this.loc;
        this.advance();

        ast.PWildcard (loc)
      }
      | token.Identifier (ident) -> this.parseIdentifierPattern(isDecl)
      | token.LeftParen -> this.parseParenthesizedPattern(isDecl)
      // Literals in declaration patterns are not allowed
      | token.BoolLiteral _
      | token.IntLiteral _
      | token.CharLiteral _
      | token.StringLiteral _ when isDecl ->
        fatal(error.LiteralInPattern, this.loc)
      // Literals in non-declaration patterns are allowed
      | token.IntLiteral { raw, base } -> {
        val loc = this.loc;
        this.advance();
        ast.PLiteral (ast.PInt (ast.IntLiteral { loc, raw, base }))
      }
      | token.BoolLiteral (value) -> {
        val loc = this.loc;
        this.advance();
        ast.PLiteral (ast.PBool (ast.BoolLiteral { loc, value }))
      }
      | token.StringLiteral (value) -> {
        val loc = this.loc;
        this.advance();
        ast.PLiteral (ast.PString (ast.StringLiteral { loc, value }))
      }
      | token.CharLiteral (value) -> {
        val loc = this.loc;
        this.advance();
        ast.PLiteral (ast.PChar (ast.CharLiteral { loc, value }))
      }
      // Minus may be start of negative int literal if not in declaration
      | token.Minus when !isDecl -> {
        val minusLoc = this.loc;
        this.advance();

        match (this.token) {
          // For this to be a negative int literal, minus sign must be immediately followed by an
          // int literal with no space between them.
          | token.IntLiteral { raw, base } when minusLoc.isAdjacentTo(this.loc) -> {
            this.advance();
            val raw = `-${raw}`;
            val loc = this.currentLoc(minusLoc);

            ast.PLiteral (ast.PInt (ast.IntLiteral { loc, raw, base }))
          }
          | _ -> fatal(error.MalformedPattern { token: token.Minus }, minusLoc)
        }
      }
      | token -> fatal(error.MalformedPattern { token }, this.loc)
    };
  }

  fun parseIdentifierPattern(isDecl: Bool): ast.Pattern {
    val startLoc = this.loc;
    val name = this.parseScopedIdentifier();

    return match (this.token) {
      | token.Wildcard -> {
        this.advance();
        val loc = this.currentLoc(startLoc);

        ast.PNamedWildcard (ast.NamedWildcard { loc, name })
      }
      | token.LeftParen -> ast.PTuple (this.parseTuplePattern(name, startLoc, isDecl))
      | token.LeftBrace -> ast.PRecord (this.parseRecordPattern(name, startLoc, isDecl))
      | _ -> ast.PIdentifier (name)
    };
  }

  fun parseTuplePattern(name: ast.ScopedIdentifier, startLoc: Loc, isDecl: Bool): ast.TuplePattern {
    this.expect(token.LeftParen);

    val elements: Vec<ast.Pattern> = [];
    while (this.token != token.RightParen) {
      elements.push(this.parsePattern(isDecl));
      match (this.token) {
        | token.RightParen -> ()
        | token.Comma -> this.advance()
        | _ -> this.expect(token.RightParen)
      }
    }

    this.advance();
    val loc = this.currentLoc(startLoc);
    
    if (elements.size == 0) {
      fatal(error.EmptyTuple, loc);
    }

    return ast.TuplePattern { loc, name: Some (name), elements };
  }

  fun parseRecordPattern(
    name: ast.ScopedIdentifier,
    startLoc: Loc,
    isDecl: Bool,
  ): ast.RecordPattern {
    this.expect(token.LeftBrace);

    var rest = false;
    val fields: Vec<ast.RecordPatternField> = [];

    while (true) {
      match (this.token) {
        // Record ends with a right element
        | token.RightBrace -> {
          this.advance();
          break;
        }
        // `...` is a rest element, and must be last element in record
        | token.Period -> {
          this.expect(token.Period);
          this.expect(token.Period);
          this.expect(token.Period);
          rest = true;

          // Rest can optionally be followed by a trailing comma, then the record must end
          if (this.token == token.Comma) {
            this.advance();
          }
          
          this.expect(token.RightBrace);
          break;
        }
        // An identifier is the start of a record field
        | token.Identifier _ -> {
          val startLoc = this.loc;
          val name = this.parseIdentifier();

          // A colon indicates this field has both a name and value
          val field = if (this.token == token.Colon) {
            this.advance();
            val value = this.parsePattern(isDecl);
            val loc = this.currentLoc(startLoc);

            ast.RecordPatternField { loc, name: Some (name), value }
          } else {
            // Otherwise this is field shorthand with just a name
            val loc = this.currentLoc(startLoc);

            ast.RecordPatternField {
              loc,
              name: None,
              value: ast.PIdentifier (ast.utils.identifierToScopedIdentifier(name)),
            }
          };

          fields.push(field);

          // Optionally followed by a trailing comma
          match (this.token) {
            | token.RightBrace -> ()
            | token.Comma -> this.advance()
            | _ -> this.expect(token.RightBrace)
          }
        }
        | _ -> this.expect(token.RightParen)
      }
    }

    val loc = this.currentLoc(startLoc);

    if (fields.size == 0) {
      fatal(error.EmptyRecord, loc);
    }

    return ast.RecordPattern { loc, name, fields, rest };
  }

  fun parseParenthesizedPattern(isDecl: Bool): ast.Pattern {
    val startLoc = this.loc;
    this.expect(token.LeftParen);

    // A unit literal can appear in non-declaration patterns
    if (this.token == token.RightParen) {
      this.advance();
      val loc = this.currentLoc(startLoc);

      if (isDecl) {
        fatal(error.LiteralInPattern, loc);
      }

      return ast.PLiteral (ast.PUnit (ast.UnitLiteral { loc }));
    }

    // Gather parenthesized elements
    val elements: Vec<ast.Pattern> = [];
    while (this.token != token.RightParen) {
      elements.push(this.parsePattern(isDecl));
      match (this.token) {
        | token.RightParen -> ()
        | token.Comma -> this.advance()
        | _ -> this.expect(token.RightParen)
      }
    }

    this.advance();

    // If there is a single element this is a parenthesized pattern, otherwise it is a tuple pattern
    return if (elements.size == 1) {
      elements[0]
    } else {
      val loc = this.currentLoc(startLoc);
      ast.PTuple (ast.TuplePattern { loc, name: None, elements })
    };
  }
}

pub fun parseFile(filename: String): Result<ast.Module, ParseError> {
  val contents = match (readFileContents(filename)) {
    | Ok (contents) -> contents
    | Error _ -> return Error (error.CannotOpenFile { filename })
  };

  val lexer = Lexer.new(filename, contents);
  val parser = Parser.new(lexer);
  val mod = parser.parse();

  return Ok (mod);
}
