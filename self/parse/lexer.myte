module myte.parse.lexer

import myte.common.loc.{Loc, Pos}
import myte.parse.ast
import myte.parse.error
import myte.parse.error.ParseError
import myte.parse.token
import myte.parse.token.Token

import std.io.println

type Lexer {
  // All bytes to tokenize
  bytes: String,
  // Name of source file that is being tokenized
  source: String,
  // Current byte
  current: LexByte,
  // Offset of current byte in bytes
  currentOffset: Int,
  // Line number of current byte
  currentLine: Int,
  // Offset of current line in bytes
  currentLineOffset: Int,
  // Position of the start of the current token
  currentTokenStartPos: Pos,
}

type TokenResult {
  loc: Loc,
  token: Token,
}

type ErrorResult {
  loc: Loc,
  error: ParseError,
}

// Bytes in the lexer are stored as a full Int to support sigil values outside the Byte range
type alias LexByte = Int

// A number outside the byte range to signal EOF has been reached
val EOF: LexByte = 128

methods Lexer {
  static fun new(source: String, bytes: String): Lexer {
    val current = if (bytes.size > 0) {
      bytes.get(0).toInt()
    } else {
      EOF
    };

    return Lexer {
      bytes,
      source,
      current,
      currentOffset: 0,
      currentLine: 1,
      currentLineOffset: 0,
      currentTokenStartPos: Pos {
        line: 1,
        column: 0,
      },
    };
  }

  fun clone(): Lexer {
    return Lexer {
      bytes: this.bytes,
      source: this.source,
      current: this.current,
      currentOffset: this.currentOffset,
      currentLine: this.currentLine,
      currentLineOffset: this.currentLineOffset,
      currentTokenStartPos: this.currentTokenStartPos,
    };
  }

  /*
   * Advance the lexer one byte.
   */
  fun advance() {
    // If current byte is a new line character, next byte will be on a new line
    if (this.current == '\n') {
      this.currentLine += 1;
      this.currentLineOffset = this.currentOffset + 1;
    }

    // Only move to next byte if not already at end
    val nextOffset = this.currentOffset + 1;
    if (nextOffset < this.bytes.size) {
      this.current = this.bytes.get(nextOffset).toInt();
      this.currentOffset = nextOffset;
    } else {
      this.current = EOF;
      this.currentOffset = this.bytes.size;
    }
  }

  /**
   * Advance the lexer two bytes.
   */
  fun advanceTwo() {
    this.advance();
    this.advance();
  }

  /**
   * Advance the lexer three bytes.
   */
  fun advanceThree() {
    this.advance();
    this.advance();
    this.advance();
   }

  /**
   * Advance the lexer four bytes.
   */
  fun advanceFour() {
    this.advance();
    this.advance();
    this.advance();
    this.advance();
  }

  /*
   * Return the next byte if not at end of source.
   */
  fun peek(): LexByte {
    val nextOffset = this.currentOffset + 1;
    return if (nextOffset < this.bytes.size) {
      this.bytes.get(nextOffset).toInt()
    } else {
      EOF
    };
  }

  /*
   * Return the byte after the next byte if not at end of source.
   */
  fun peekTwo(): LexByte {
    val nextOffset = this.currentOffset + 2;
    return if (nextOffset < this.bytes.size) {
      this.bytes.get(nextOffset).toInt()
    } else {
      EOF
    };
  }

  /*
   * Return the byte two bytes after the next byte if not at end of source.
   */
  fun peekThree(): LexByte {
    val nextOffset = this.currentOffset + 3;
    return if (nextOffset < this.bytes.size) {
      this.bytes.get(nextOffset).toInt()
    } else {
      EOF
    };
  }

  fun getCurrentPos(): Pos =
    Pos { line: this.currentLine, column: this.currentOffset - this.currentLineOffset }
  
  fun locOfPosition(pos: Pos): Loc =
    Loc { source: this.source, start: pos, end: Pos { line: pos.line, column: pos.column + 1 } }
  
  fun tokenResult(token: Token): Result<TokenResult, ErrorResult> {
    val loc = Loc {
      source: this.source,
      start: this.currentTokenStartPos,
      end: this.getCurrentPos(),
    };

    return Ok (TokenResult { loc, token });
  }

  fun tokenResultFromPos(token: Token, startPos: Pos): Result<TokenResult, ErrorResult> {
    val loc = Loc { source: this.source, start: startPos, end: this.getCurrentPos() };

    return Ok (TokenResult { loc, token });
  }

  fun errorResultAtCurrentPos(error: ParseError): Result<TokenResult, ErrorResult> {
    val loc = this.locOfPosition(this.getCurrentPos());

    return Error (ErrorResult { error, loc });
  }

  fun errorResultFromPos(error: ParseError, startPos: Pos): Result<TokenResult, ErrorResult> {
    val loc = Loc { source: this.source, start: startPos, end: this.getCurrentPos() };

    return Error (ErrorResult { error, loc });
  }

  /*
   * Return the next token in the source, or an error if an error was encountered.
   */
  fun next(): Result<TokenResult, ErrorResult> {
    // Skip over all whitespace before token
    while (true) {
      match (this.current) {
        | ' '
        | '\n'
        | '\r'
        | '\t' -> this.advance()
        | _ -> break
      }
    }

    // Save the current position
    this.currentTokenStartPos = this.getCurrentPos();

    // Check if first character is for an identifier or keyword
    val current = this.current;
    if (('a' <= current && current <= 'z') ||
        ('A' <= current && current <= 'Z') ||
        (current == '_')) {
      return this.tokenResult(this.parseIdentifierOrKeyword());
    }
    
    // Check for hexadecimal integer literal
    if (current == '0' && this.peek() == 'x' && this.isHexDigit(this.peekTwo())) {
      return this.tokenResult(this.parseNumberHex());
    }

    // Check for binary integer literal
    if (current == '0' && this.peek() == 'b' && this.isBinDigit(this.peekTwo())) {
      return this.tokenResult(this.parseNumberBin());
    }

    // Otherwise is a decimal integer literal
    if ('0' <= current && current <= '9') {
      return this.tokenResult(this.parseNumberDec());
    }

    return match (current) {
      | ';' -> {
        this.advance();
        this.tokenResult(token.Semicolon)
      }
      | ':' -> {
        this.advance();
        this.tokenResult(token.Colon)
      }
      | ',' -> {
        this.advance();
        this.tokenResult(token.Comma)
      }
      | '.' -> {
        this.advance();
        this.tokenResult(token.Period)
      }
      | '=' -> match (this.peek()) {
        | '=' -> {
          this.advanceTwo();
          this.tokenResult(token.DoubleEquals)
        }
        | _ -> {
          this.advance();
          this.tokenResult(token.Equals)
        }
      }
      | '|' -> match (this.peek()) {
        | '|' -> {
          this.advanceTwo();
          this.tokenResult(token.LogicalOr)
        }
        | '=' -> {
          this.advanceTwo();
          this.tokenResult(token.PipeEquals)
        }
        | '}' -> {
          this.advanceTwo();
          this.tokenResult(token.SetClose)
        }
        | _ -> {
          this.advance();
          this.tokenResult(token.Pipe)
        }
      }
      | '+' -> match (this.peek()) {
        | '=' -> {
          this.advanceTwo();
          this.tokenResult(token.PlusEquals)
        }
        | _ -> {
          this.advance();
          this.tokenResult(token.Plus)
        }
      }
      | '-' -> match (this.peek()) {
        | '>' -> {
          this.advanceTwo();
          this.tokenResult(token.Arrow)
        }
        | '=' -> {
          this.advanceTwo();
          this.tokenResult(token.MinusEquals)
        }
        | _ -> {
          this.advance();
          this.tokenResult(token.Minus)
        }
      }
      | '*' -> match (this.peek()) {
        | '=' -> {
          this.advanceTwo();
          this.tokenResult(token.MultiplyEquals)
        }
        | _ -> {
          this.advance();
          this.tokenResult(token.Multiply)
        }
      }
      | '%' -> match (this.peek()) {
        | '=' -> {
          this.advanceTwo();
          this.tokenResult(token.PercentEquals)
        }
        | _ -> {
          this.advance();
          this.tokenResult(token.Percent)
        }
      }
      | '&' -> match (this.peek()) {
        | '&' -> {
          this.advanceTwo();
          this.tokenResult(token.LogicalAnd)
        }
        | '=' -> {
          this.advanceTwo();
          this.tokenResult(token.AmpersandEquals)
        }
        | _ -> {
          this.advance();
          this.tokenResult(token.Ampersand)
        }
      }
      | '^' -> match (this.peek()) {
        | '=' -> {
          this.advanceTwo();
          this.tokenResult(token.CaretEquals)
        }
        | _ -> {
          this.advance();
          this.tokenResult(token.Caret)
        }
      }
      | '?' -> {
        this.advance();
        this.tokenResult(token.Question)
      }
      | '!' -> match (this.peek()) {
        | '=' -> {
          this.advanceTwo();
          this.tokenResult(token.NotEquals)
        }
        | _ -> {
          this.advance();
          this.tokenResult(token.Bang)
        }
      }
      | '(' -> {
        this.advance();
        this.tokenResult(token.LeftParen)
      }
      | ')' -> {
        this.advance();
        this.tokenResult(token.RightParen)
      }
      | '{' -> match (this.peek()) {
        | '|' -> {
          this.advanceTwo();
          this.tokenResult(token.SetOpen)
        }
        | _ -> {
          this.advance();
          this.tokenResult(token.LeftBrace)
        }
      }
      | '}' -> {
        this.advance();
        this.tokenResult(token.RightBrace)
      }
      | '[' -> {
        this.advance();
        this.tokenResult(token.LeftBracket)
      }
      | ']' -> {
        this.advance();
        this.tokenResult(token.RightBracket)
      }
      | '<' -> match (this.peek()) {
        | '=' -> {
          this.advanceTwo();
          this.tokenResult(token.LessThanOrEqual)
        }
        | '<' -> match (this.peekTwo()) {
          | '=' -> {
            this.advanceThree();
            this.tokenResult(token.LeftShiftEquals)
          } 
          | _ -> {
            this.advance();
            this.tokenResult(token.LessThan)
          }
        }
        | _ -> {
          this.advance();
          this.tokenResult(token.LessThan)
        }
      }
      | '>' -> match (this.peek()) {
        | '=' -> {
          this.advanceTwo();
          this.tokenResult(token.GreaterThanOrEqual)
        }
        | '>' -> match (this.peekTwo()) {
          | '=' -> {
            this.advanceThree();
            this.tokenResult(token.ArithmeticRightShiftEquals)
          }
          | '>' -> match (this.peekThree()) {
            | '=' -> {
              this.advanceFour();
              this.tokenResult(token.LogicalRightShiftEquals)
            }
            | _ -> {
              this.advance();
              this.tokenResult(token.GreaterThan)
            }
          }
          | _ -> {
            this.advance();
            this.tokenResult(token.GreaterThan)
          }
        }
        | _ -> {
          this.advance();
          this.tokenResult(token.GreaterThan)
        }
      }
      | '"' -> {
        this.advance();
        this.parseStringLiteral(false, this.currentTokenStartPos)
      }
      | '`' -> {
        this.advance();
        this.parseStringLiteral(true, this.currentTokenStartPos)
      }
      | '\'' -> this.parseCharLiteral()
      | '/' -> match (this.peek()) {
        | '/' -> {
          this.advanceTwo();

          // Skip characters in line comment
          while (true) {
            match (this.current) {
              | '\n'
              | '\r' -> break
              | current when current == EOF -> break
              | _ -> this.advance()
            }
          }

          this.next()
        }
        | '*' -> {
          this.advanceTwo();
          
          // Skip characters in block comment
          while (true) {
            match (this.current) {
              | '*' -> match (this.peek()) {
                | '/' -> {
                  this.advanceTwo();
                  break;
                }
                | _ -> ()
              }
              // Error on unclosed block comment
              | current when current == EOF -> {
                val loc = Loc {
                  source: this.source,
                  start: this.currentTokenStartPos,
                  end: this.getCurrentPos(),
                };
                val error = error.UnexpectedToken { actual: token.Eof, expected: None };

                return Error (ErrorResult { error, loc });
              }
              | _ -> ()
            }

            this.advance();
          }

          this.next()
        }
        | '=' -> {
          this.advanceTwo();
          this.tokenResult(token.DivideEquals)
        }
        | _ -> {
          this.advance();
          this.tokenResult(token.Divide)
        }
      }
      | current when current == EOF -> this.tokenResult(token.Eof)
      // Error on unkown token
      | current -> {
        this.advance();
        val loc = Loc {
          source: this.source,
          start: this.currentTokenStartPos,
          end: this.getCurrentPos(),
        };

        val raw = "";
        raw.push(current.toByte());

        Error (ErrorResult { error: error.UnknownToken { raw }, loc })
      }
    };
  }

  fun nextInInterpolatedString(): Result<TokenResult, ErrorResult> {
    // Adjust pos to start at '}' which must precede this call
    val currentPos = this.getCurrentPos();
    val adjustedStartPos = Pos { line: currentPos.line, column: currentPos.column - 1 };

    return this.parseStringLiteral(true, adjustedStartPos);
  }

  fun parseIdentifierOrKeyword(): Token {
    val raw = "";
    var current = this.current;

    // Collect all characters in identifier
    while (('a' <= current && current <= 'z') ||
           ('A' <= current && current <= 'Z') ||
           ('0' <= current && current <= '9') ||
           (current == '_')) {
      raw.push(current.toByte());

      this.advance();
      current = this.current;
    }

    // Check if this is a keyword or identifier
    return match (raw) {
      | "_" -> token.Wildcard
      | "true" -> token.BoolLiteral (true)
      | "false" -> token.BoolLiteral (false)
      | "val" -> token.Val
      | "var" -> token.Var
      | "fun" -> token.Fun
      | "fn" -> token.Fn
      | "type" -> token.Type
      | "trait" -> token.Trait
      | "if" -> token.If
      | "else" -> token.Else
      | "while" -> token.While
      | "for" -> token.For
      | "in" -> token.In
      | "match" -> token.Match
      | "when" -> token.When
      | "return" -> token.Return
      | "break" -> token.Break
      | "continue" -> token.Continue
      | "alias" -> token.Alias
      | "builtin" -> token.Builtin
      | "override" -> token.Override
      | "static" -> token.Static
      | "methods" -> token.Methods
      | "implements" -> token.Implements
      | "extends" -> token.Extends
      | "module" -> token.Module
      | "import" -> token.Import
      | "as" -> token.As
      | _ -> token.Identifier (raw)
    };
  }

  fun isHexDigit(byte: LexByte): Bool =
    ('0' <= this.current && this.current <= '9') ||
    ('a' <= this.current && this.current <= 'f') ||
    ('A' <= this.current && this.current <= 'F')
  
  fun isBinDigit(byte: LexByte): Bool = byte == '0' || byte == '1'

  fun parseNumberDec(): Token {
    val startOffset = this.currentOffset;
    while ('0' <= this.current && this.current <= '9') {
      this.advance();
    }

    val raw = this.bytes.substring(startOffset, this.currentOffset);

    return token.IntLiteral { raw, base: ast.Dec };
  }

  fun parseNumberHex(): Token {
    val startOffset = this.currentOffset;

    // Skip `0x` prefix
    this.advanceTwo();

    // Find all hex digits in number
    while (this.isHexDigit(this.current)) {
      this.advance();
    }

    val raw = this.bytes.substring(startOffset, this.currentOffset);

    return token.IntLiteral { raw, base: ast.Hex };
  }

  fun parseNumberBin(): Token {
    val startOffset = this.currentOffset;

    // Skip `0b` prefix
    this.advanceTwo();

    // Find all binary digits in number
    while (this.isBinDigit(this.current)) {
      this.advance();
    }

    val raw = this.bytes.substring(startOffset, this.currentOffset);

    return token.IntLiteral { raw, base: ast.Bin };
  }

  fun parseStringLiteral(inInterpolated: Bool, startPos: Pos): Result<TokenResult, ErrorResult> {
    val string = "";
    while (true) {
      match (this.current) {
        // Double quotes are end for string literal
        | '"' when !inInterpolated -> {
          this.advance();
          break;
        }
        // Backtick is end for interpolated string literal
        | '`' when inInterpolated -> {
          this.advance();
          return this.tokenResultFromPos(
            token.InterpolatedString { string, isEnd: true },
            startPos,
          );
        }
        // `${` marks the beginning of an expression in an interpolated string
        | '$' when inInterpolated -> match (this.peek()) {
          | '{' -> {
            this.advanceTwo();
            return this.tokenResultFromPos(
              token.InterpolatedString { string, isEnd: false },
              startPos,
            );
          }
          | _ -> {
            string.push('$');
            this.advance();
          }
        }
        // Newlines are allowed in interpolated strings, but not normal string literals
        | '\n' when !inInterpolated -> {
          val loc = this.locOfPosition(startPos);
          return Error (ErrorResult { error: error.UnterminatedStringLiteral, loc });
        }
        // Start of an escape sequence sequence
        | '\\' -> {
          val escapeStartPos = this.getCurrentPos();
          this.advance();

          val decoded = match (this.current) {
            // Escape sequences for both string literals and interpolated strings
            | 'n' -> {
              this.advance();
              '\n'
            }
            | 'r' -> {
              this.advance();
              '\r'
            }
            | 't' -> {
              this.advance();
              '\t'
            }
            | '\\' -> {
              this.advance();
              '\\'
            }
            // Double quotes are only an escape sequence in string literals
            | '"' -> {
              if (inInterpolated) {
                return this.errorResultAtCurrentPos(error.InvalidStringEscape { inInterpolated });
              } else {
                this.advance();
                '"'
              }
            }
            // Backtick is only an escape sequence in string literals
            | '`' -> {
              if (inInterpolated) {
                this.advance();
                '`'
              } else {
                return this.errorResultAtCurrentPos(error.InvalidStringEscape { inInterpolated });
              }
            }
            // Dollar sign is only an escape sequence in string literals
            | '$' -> {
              if (inInterpolated) {
                this.advance();
                '$'
              } else {
                return this.errorResultAtCurrentPos(error.InvalidStringEscape { inInterpolated });
              }
            }
            // Start of a hex escape sequence
            | 'x' -> {
              this.advance();

              val digit1 = this.parseHexDigit(this.current);
              if (digit1 == -1) {
                return this.errorResultFromPos(error.InvalidHexEscape, escapeStartPos);
              }
              this.advance();

              val digit2 = this.parseHexDigit(this.current);
              if (digit2 == -1) {
                return this.errorResultFromPos(error.InvalidHexEscape, escapeStartPos);
              }
              this.advance();

              digit1 * 16 + digit2
            }
            | _ -> return this.errorResultAtCurrentPos(error.InvalidStringEscape { inInterpolated })
          };

          string.push(decoded.toByte());
        }
        | current when current == EOF -> {
          val loc = this.locOfPosition(startPos);
          return Error (ErrorResult { error: error.UnterminatedStringLiteral, loc });
        }
        | current -> {
          string.push(current.toByte());
          this.advance();
        }
      }
    }

    return this.tokenResultFromPos(token.StringLiteral (string), startPos);
  }

  /**
   * Parse a hex digit character to its integer value, returning -1 if it is not a hex digit.
   */
  fun parseHexDigit(n: Int): Int {
    return if ('0' <= n && n <= '9') {
      n - '0'
    } else if ('a' <= n && n <= 'f') {
      n - 'a' + 10
    } else if ('A' <= n && n <= 'F') {
      n - 'A' + 10
    } else {
      -1
    };
  }

  fun parseCharLiteral(): Result<TokenResult, ErrorResult> {
    this.advance();
    
    val value = match (this.current) {
      // Unescaped single quote is not allowed
      | '\'' -> return this.errorResultAtCurrentPos(error.MalformedCharLiteral)
      // Escape sequences for char literals
      | '\\' -> {
        this.advance();
        match (this.current) {
          | '\'' -> '\''
          | '\\' -> '\\'
          | 'n' -> '\n'
          | 'r' -> '\r'
          | 't' -> '\t'
          | _ -> return this.errorResultAtCurrentPos(error.InvalidCharEscape)
        }
      }
      // All other printable chars are allowed
      | current when ' ' <= current && current <= '~' -> current
      | _ -> return this.errorResultAtCurrentPos(error.MalformedCharLiteral)
    };

    this.advance();

    // Char literal must be closed by another single quote
    return match (this.current) {
      | '\'' -> {
        this.advance();
        this.tokenResult(token.CharLiteral (value.toByte()))
      }
      | _ -> this.errorResultAtCurrentPos(error.MalformedCharLiteral)
    };
  }
}