module myte.parse.printer

import myte.common.loc.Loc
import myte.parse.ast
import myte.parse.ast.utils.escapeCharLiteralValue

type PrintNode =
  | Empty
  | Int (Int)
  | String (String)
  | Bool (Bool)
  | Raw (String)
  | List (Vec<PrintNode>)
  | Node {
    name: String,
    loc: Loc,
    fields: Vec<(String, PrintNode)>
  }

type Printer {
  builder: String,
  indent: Int,
}

methods Printer {
  static fun new(): Printer = Printer { builder: "", indent: 0 }

  fun addChar(byte: Byte) {
    this.builder.push(byte);
  }

  fun addString(string: String) {
    this.builder.append(string);
  }

  fun addLoc(loc: Loc) {
    this.addString(`${loc.start.line}:${loc.start.column}-${loc.end.line}:${loc.end.column}`);
  }

  fun addIndent() {
    this.addString(String.repeat("  ", this.indent));
  }

  fun visitNode(node: PrintNode) {
    match (node) {
      | Empty -> this.addString("None")
      | Int (int) -> this.addString(int.toString())
      | String (string) -> {
        this.addChar('"');
        this.addString(string);
        this.addChar('"');
      }
      | Bool (bool) -> this.addString(bool.toString())
      | Raw (raw) -> this.addString(raw)
      | List (nodes) -> {
        if (nodes.size == 0) {
          this.addString("[]");
        } else {
          this.addString("[\n");
          this.indent += 1;

          for (node in nodes) {
            this.addIndent();
            this.visitNode(node);
            this.addString(",\n");
          }

          this.indent -= 1;
          this.addIndent();
          this.addChar(']');
        }
      }
      | Node { name, loc, fields } -> {
        this.addString("{\n");
        this.indent += 1;

        // Add node type
        this.addIndent();
        this.addString("node: ");
        this.addString(name);
        this.addString(",\n");

        // Add loc
        this.addIndent();
        this.addString("loc: ");
        this.addLoc(loc);
        this.addString(",\n");

        // Add fields
        for ((name, node) in fields) {
          this.addIndent();
          this.addString(name);
          this.addString(": ");
          this.visitNode(node);
          this.addString(",\n");
        }

        this.indent -= 1;
        this.addIndent();
        this.addChar('}');
      }
    }
  }
}

fun optional<T>(x: Option<T>, f: (T) -> PrintNode): PrintNode =
  match (x) {
    | None -> Empty
    | Some (x) -> f(x)
  }

fun printModule(mod: ast.Module): String {
  val node = nodeOfModule(mod);
  val printer = Printer.new();
  printer.visitNode(node);

  return printer.builder;
}

fun nodeOfModule(mod: ast.Module): PrintNode {
  val ast.Module { loc, name, imports, toplevels } = mod;
  return Node {
    name: "Module",
    loc,
    fields: [
      ("name", nodeOfModuleName(name)),
      ("imports", List (imports.map(nodeOfImport))),
      ("toplevels", List (toplevels.map(nodeOfToplevel))),
    ],
  };
}

fun nodeOfModuleName(name: ast.ModuleName): PrintNode {
  val ast.ModuleName { loc, name } = name;
  return Node { name: "ModuleName", loc, fields: [("name", nodeOfScopedIdentifier(name))] };
}

fun nodeOfImport(import_: ast.Import): PrintNode =
  match (import_) {
    | ast.ISimpleImport (i) -> nodeOfScopedIdentifier(i)
    | ast.IComplexImport (t) -> nodeOfComplexImport(t)
  }

fun nodeOfComplexImport(complex: ast.ComplexImport): PrintNode {
  val ast.ComplexImport { loc, scopes, aliases } = complex;
  return Node {
    name: "ComplexImport",
    loc,
    fields: [
      ("scopes", List (scopes.map(nodeOfIdentifier))),
      ("aliases", List (aliases.map(nodeOfImportAlias))),
    ],
  };
}

fun nodeOfImportAlias(alias_: ast.ImportAlias): PrintNode {
  val ast.ImportAlias { loc, name, alias_ } = alias_;
  return Node {
    name: "ImportAlias",
    loc,
    fields: [("name", nodeOfIdentifier(name)), ("alias", optional(alias_, nodeOfIdentifier))],
  };
}

fun nodeOfToplevel(toplevel: ast.Toplevel): PrintNode =
  match (toplevel) {
    | ast.TLFunction (t) -> nodeOfFunctionDeclaration(t)
    | ast.TLVariable (t) -> nodeOfVariableDeclaration(t)
    | ast.TLType (t) -> nodeOfTypeDeclaration(t)
  }

fun nodeOfFunctionDeclaration(decl: ast.FunctionDeclaration): PrintNode {
  val ast.FunctionDeclaration
    { loc, name, params, body, ret, typeParams, isBuiltin, isStatic, isOverride } = decl;
  val body = match (body) {
    | ast.FBBlock (block) -> nodeOfBlock(block)
    | ast.FBExpression (expr) -> nodeOfExpression(expr)
    | ast.FBSignature -> Empty
  };
  
  return Node {
    name: "Function",
    loc,
    fields: [
      ("name", nodeOfIdentifier(name)),
      ("params", List (params.map(nodeOfFunctionParam))),
      ("body", body),
      ("return", optional(ret, nodeOfType)),
      ("type_params", List (typeParams.map(nodeOfTypeParameter))),
      ("builtin", Bool (isBuiltin)),
      ("static", Bool (isStatic)),
      ("override", Bool (isOverride)),
    ]
  };
}

fun nodeOfFunctionParam(param: ast.FunctionParam): PrintNode {
  val ast.FunctionParam { loc, name, annot } = param;
  return Node {
    name: "Param",
    loc,
    fields: [("name", nodeOfIdentifier(name)), ("annot", nodeOfType(annot))],
  };
}

fun nodeOfTypeParameter(param: ast.TypeParameter): PrintNode {
  val ast.TypeParameter { loc, name, bounds } = param;
  return Node {
    name: "TypeParameter",
    loc,
    fields: [("name", nodeOfIdentifier(name)), ("bounds", List (bounds.map(nodeOfIdentifierType)))],
  };
}

fun nodeOfVariableDeclaration(decl: ast.VariableDeclaration): PrintNode {
  val ast.VariableDeclaration { loc, kind, pattern, init, annot } = decl;
  val kind = match (kind) {
    | ast.Immutable -> "Immutable"
    | ast.Mutable -> "Mutable"
  };

  return Node {
    name: "VariableDeclaration",
    loc,
    fields: [
      ("kind", Raw (kind)),
      ("pattern", nodeOfScopedIdentifier(pattern)),
      ("init", nodeOfExpression(init)),
      ("annot", optional(annot, nodeOfType)),
    ],
 };
}

fun nodeOfTypeDeclaration(decl: ast.TypeDeclaration): PrintNode {
  val ast.TypeDeclaration { loc, name, typeParams, decl } = decl;
  val decl = match (decl) {
    | ast.TDAlias (typeAlias) -> ("alias", nodeOfType(typeAlias))
    | ast.TDTuple (tuple) -> ("tuple", nodeOfTupleDeclaration(tuple))
    | ast.TDRecord (record) -> ("record", nodeOfRecordDeclaration(record))
    | ast.TDVariant (variants) -> ("variants", List (variants.map(nodeOfVariantDeclaration)))
    | ast.TDBuiltin -> ("builtin", Bool (true))
  };

  return Node {
    name: "TypeDeclaration",
    loc,
    fields: [
      ("name", nodeOfIdentifier(name)),
      ("type_params", List (typeParams.map(nodeOfTypeParameter))),
      decl,
    ],
 };
}

fun nodeOfTupleDeclaration(decl: ast.TupleDeclaration): PrintNode {
  val ast.TupleDeclaration { loc, name, elements } = decl;
  return Node {
    name: "TupleVariant",
    loc,
    fields: [("name", nodeOfIdentifier(name)), ("elements", List (elements.map(nodeOfType)))],
  };
}

fun nodeOfRecordDeclaration(decl: ast.RecordDeclaration): PrintNode {
  val ast.RecordDeclaration { loc, name, fields } = decl;
  return Node {
    name: "RecordVariant",
    loc,
    fields: [
      ("name", nodeOfIdentifier(name)),
      ("fields", List (fields.map(nodeOfRecordDeclarationField))),
    ],
  };
}

fun nodeOfRecordDeclarationField(field: ast.RecordDeclarationField): PrintNode {
  val ast.RecordDeclarationField { loc, name, ty } = field;
  return Node {
    name: "RecordVariantField",
    loc,
    fields: [("name", nodeOfIdentifier(name)), ("type", nodeOfType(ty))],
  };
}

fun nodeOfVariantDeclaration(decl: ast.VariantDeclaration): PrintNode =
  match (decl) {
    | ast.EnumVariant (ident) -> nodeOfIdentifier(ident)
    | ast.TupleVariant (tuple) -> nodeOfTupleDeclaration(tuple)
    | ast.RecordVariant (record) -> nodeOfRecordDeclaration(record)
  }

fun nodeOfIdentifier(ident: ast.Identifier): PrintNode {
  val ast.Identifier { loc, name } = ident;
  return Node { name: "Identifier", loc, fields: [("name", String (name))] };
}

fun nodeOfScopedIdentifier(ident: ast.ScopedIdentifier): PrintNode {
  val ast.ScopedIdentifier { loc, scopes, name } = ident;
  return Node {
    name: "ScopedIdentifier",
    loc,
    fields: [("scopes", List (scopes.map(nodeOfIdentifier))), ("name", nodeOfIdentifier(name))],
  };
}

fun nodeOfStatement(stmt: ast.Statement): PrintNode =
  match (stmt) {
    | ast.SBlock (s) -> nodeOfBlock(s)
    | ast.SExpression (s) -> nodeOfExpressionStatement(s)
    | ast.SVariableDeclaration (s) -> nodeOfVariableDeclaration(s)
    | ast.SWhile (s) -> nodeOfWhile(s)
    | ast.SReturn (s) -> nodeOfReturn(s)
    | ast.SBreak (s) -> nodeOfBreak(s)
    | ast.SContinue (s) -> nodeOfContinue(s)
  }

fun nodeOfBlock(block: ast.Block): PrintNode {
  val ast.Block { loc, statements } = block;
  return Node {
    name: "Block",
    loc,
    fields: [("statements", List (statements.map(nodeOfStatement)))],
  };
}

fun nodeOfExpressionStatement(block: ast.ExpressionStatement): PrintNode {
  val ast.ExpressionStatement { loc, expr, isValue } = block;
  val fields = [("expression", nodeOfExpression(expr))];
  if (isValue) {
    fields.push(("is_value", Bool (true)));
  }

  return Node { name: "ExpressionStatement", loc, fields };
}

fun nodeOfWhile(w: ast.While): PrintNode {
  val ast.While { loc, test, body } = w;
  return Node {
    name: "While",
    loc,
    fields: [("test", nodeOfExpression(test)), ("body", nodeOfBlock(body))],
  };
}

fun nodeOfReturn(r: ast.Return): PrintNode {
  val ast.Return { loc, arg } = r;
  return Node { name: "Return", loc, fields: [("arg", optional(arg, nodeOfExpression))] };
}

fun nodeOfBreak(b: ast.Break): PrintNode {
  val ast.Break { loc } = b;
  return Node { name: "Break", loc, fields: [] };
}


fun nodeOfContinue(b: ast.Continue): PrintNode {
  val ast.Continue { loc } = b;
  return Node { name: "Continue", loc, fields: [] };
}

fun nodeOfExpression(expr: ast.Expression): PrintNode =
  match (expr) {
    | ast.EUnitLiteral (e) -> nodeOfUnitLiteral(e)
    | ast.EIntLiteral (e) -> nodeOfIntLiteral(e)
    | ast.EBoolLiteral (e) -> nodeOfBoolLiteral(e)
    | ast.EStringLiteral (e) -> nodeOfStringLiteral(e)
    | ast.ECharLiteral (e) -> nodeOfCharLiteral(e)
    | ast.EInterpolatedString (e) -> nodeOfInterpolatedString(e)
    | ast.EIdentifier (e) -> nodeOfIdentifier(e)
    | ast.ETuple (e) -> nodeOfTupleExpression(e)
    | ast.ETypeCast (e) -> nodeOfTypeCast(e)
    | ast.ECall (e) -> nodeOfCall(e)
    | ast.EUnaryOperation (e) -> nodeOfUnaryOperation(e)
    | ast.EBinaryOperation (e) -> nodeOfBinaryOperation(e)
    | ast.ELogicalAnd (e) -> nodeOfLogicalAnd(e)
    | ast.ELogicalOr (e) -> nodeOfLogicalOr(e)
    | ast.ENamedAccess (e) -> nodeOfNamedAccess(e)
    | ast.EIndexedAccess (e) -> nodeOfIndexedAccess(e)
    | ast.EUnwrap (e) -> nodeOfUnwrap(e)
  }

fun nodeOfUnitLiteral(lit: ast.UnitLiteral): PrintNode {
  val ast.UnitLiteral { loc } = lit;
  return Node { name: "Unit", loc, fields: [] };
}

fun nodeOfIntLiteral(lit: ast.IntLiteral): PrintNode {
  val ast.IntLiteral { loc, raw, base } = lit;
  val fields = [("raw", String (raw))];
  match (base) {
    | ast.Dec -> ()
    | ast.Bin -> fields.push(("base", String ("Bin")))
    | ast.Hex -> fields.push(("base", String ("Hex")))
  }

  return Node { name: "IntLiteral", loc, fields };
}

fun nodeOfBoolLiteral(lit: ast.BoolLiteral): PrintNode {
  val ast.BoolLiteral { loc, value } = lit;
  return Node { name: "BoolLiteral", loc, fields: [("value", Bool (value))] };
}

fun nodeOfStringLiteral(lit: ast.StringLiteral): PrintNode {
  val ast.StringLiteral { loc, value } = lit;
  return Node { name: "StringLiteral", loc, fields: [("value", String (value))] };
}

fun nodeOfCharLiteral(lit: ast.CharLiteral): PrintNode {
  val ast.CharLiteral { loc, value } = lit;
  return Node {
    name: "CharLiteral",
    loc,
    fields: [("value", String (escapeCharLiteralValue(value)))] };
}

fun nodeOfInterpolatedString(string: ast.InterpolatedString): PrintNode {
  val ast.InterpolatedString { loc, parts } = string;
  return Node {
    name: "InterpolatedString",
    loc,
    fields: [("parts", List (parts.map(nodeOfInterpolatedStringPart)))],
  };
}

fun nodeOfInterpolatedStringPart(part: ast.InterpolatedStringPart): PrintNode =
  match (part) {
    | ast.IPString (string) -> nodeOfStringLiteral(string)
    | ast.IPExpression (expr) -> nodeOfExpression(expr)
  }

fun nodeOfTupleExpression(tuple: ast.TupleExpression): PrintNode {
  val ast.TupleExpression { loc, elements } = tuple;
  return Node {
    name: "TupleExpression",
    loc,
    fields: [("elements", List (elements.map(nodeOfExpression)))],
  };
}

fun nodeOfTypeCast(tuple: ast.TypeCast): PrintNode {
  val ast.TypeCast { loc, expr, ty } = tuple;
  return Node {
    name: "TypeCast",
    loc,
    fields: [("expr", nodeOfExpression(expr)), ("type", nodeOfType(ty))],
  };
}

fun nodeOfCall(call: ast.Call): PrintNode {
  val ast.Call { loc, func, args } = call;
  return Node {
    name: "Call",
    loc,
    fields: [("func", nodeOfExpression(func)), ("args", List (args.map(nodeOfExpression)))],
  };
}

fun nodeOfUnaryOperation(unary: ast.UnaryOperation): PrintNode {
  val ast.UnaryOperation { loc, op, operand } = unary;
  val op = match (op) {
    | ast.UnaryPlus -> "Plus"
    | ast.UnaryMinus -> "Minus"
    | ast.UnaryNot -> "Not"
  };

  return Node {
    name: "UnaryOperation",
    loc,
    fields: [("op", Raw (op)), ("operand", nodeOfExpression(operand))],
  };
}

fun nodeOfBinaryOperation(binary: ast.BinaryOperation): PrintNode {
  val ast.BinaryOperation { loc, op, left, right } = binary;
  val op = match (op) {
    | ast.BinaryAdd -> "Add"
    | ast.BinarySubtract -> "Subtract"
    | ast.BinaryMultiply -> "Multiply"
    | ast.BinaryDivide -> "Divide"
    | ast.BinaryRemainder -> "Remainder"
    | ast.BinaryEqual -> "Equal"
    | ast.BinaryNotEqual -> "NotEqual"
    | ast.BinaryLessThan -> "LessThan"
    | ast.BinaryGreaterThan -> "GreaterThan"
    | ast.BinaryLessThanOrEqual -> "LessThanOrEqual"
    | ast.BinaryGreaterThanOrEqual -> "GreaterThanOrEqual"
    | ast.BinaryBitwiseAnd -> "BitwiseAnd"
    | ast.BinaryBitwiseOr -> "BitwiseOr"
    | ast.BinaryBitwiseXor -> "BitwiseXor"
    | ast.BinaryLeftShift -> "LeftShift"
    | ast.BinaryArithmeticRightShift -> "ArithmeticRightShift"
    | ast.BinaryLogicalRightShift -> "LogicalRightShift"
  };

  return Node {
    name: "BinaryOperation",
    loc,
    fields: [
      ("op", Raw (op)),
      ("left", nodeOfExpression(left)),
      ("right", nodeOfExpression(right)),
    ],
  };
}

fun nodeOfLogicalAnd(logical: ast.LogicalAnd): PrintNode {
  val ast.LogicalAnd { loc, left, right } = logical;
  return Node {
    name: "LogicalAnd",
    loc,
    fields: [("left", nodeOfExpression(left)), ("right", nodeOfExpression(right))],
  };
}

fun nodeOfLogicalOr(logical: ast.LogicalOr): PrintNode {
  val ast.LogicalOr { loc, left, right } = logical;
  return Node {
    name: "LogicalOr",
    loc,
    fields: [("left", nodeOfExpression(left)), ("right", nodeOfExpression(right))],
  };
}

fun nodeOfNamedAccess(access: ast.NamedAccess): PrintNode {
  val ast.NamedAccess { loc, target, name } = access;
  return Node {
    name: "NamedAccess",
    loc,
    fields: [("target", nodeOfExpression(target)), ("name", nodeOfIdentifier(name))],
  };
}

fun nodeOfIndexedAccess(access: ast.IndexedAccess): PrintNode {
  val ast.IndexedAccess { loc, target, index } = access;
  return Node {
    name: "IndexedAccess",
    loc,
    fields: [("target", nodeOfExpression(target)), ("index", nodeOfExpression(index))],
  };
}

fun nodeOfUnwrap(unwrap: ast.Unwrap): PrintNode {
  val ast.Unwrap { loc, operand } = unwrap;
  return Node { name: "Unwrap", loc, fields: [("operand", nodeOfExpression(operand))]};
}

fun nodeOfType(ty: ast.Type): PrintNode =
  match (ty) {
    | ast.TIdentifier (t) -> nodeOfIdentifierType(t)
    | ast.TTuple (t) -> nodeOfTupleType(t)
    | ast.TFunction (t) -> nodeOfFunctionType(t)
    | ast.TTrait (t) -> nodeOfTraitType(t)
  }

fun nodeOfIdentifierType(ident: ast.IdentifierType): PrintNode {
  val ast.IdentifierType { loc, name, typeArgs } = ident;
  return Node {
    name: "IdentifierType",
    loc,
    fields: [
      ("name", nodeOfScopedIdentifier(name)),
      ("type_args", List (typeArgs.map(nodeOfType))),
    ],
  };
}

fun nodeOfTupleType(tuple: ast.TupleType): PrintNode {
  val ast.TupleType { loc, elements } = tuple;
  return Node { name: "TupleType", loc, fields: [("elements", List (elements.map(nodeOfType)))] };
}

fun nodeOfFunctionType(func: ast.FunctionType): PrintNode {
  val ast.FunctionType { loc, params, return_ } = func;
  return Node {
    name: "FunctionType",
    loc, fields: [("params", List (params.map(nodeOfType))), ("return", nodeOfType(return_))] };
}

fun nodeOfTraitType(trait_: ast.TraitType): PrintNode {
  val ast.TraitType { loc, trait_ } = trait_;
  return Node { name: "TraitType", loc, fields: [("trait", nodeOfIdentifierType(trait_))] };
}
