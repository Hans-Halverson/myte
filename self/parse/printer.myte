module myte.parse.printer

import myte.common.loc.Loc
import myte.parse.ast
import myte.parse.ast.utils.escapeCharLiteralValue

type PrintNode =
  | Empty
  | Int (Int)
  | String (String)
  | Bool (Bool)
  | Raw (String)
  | List (Vec<PrintNode>)
  | Node {
    name: String,
    loc: Loc,
    fields: Vec<(String, PrintNode)>
  }

type Printer {
  builder: String,
  indent: Int,
}

methods Printer {
  static fun new(): Printer = Printer { builder: "", indent: 0 }

  fun addChar(byte: Byte) {
    this.builder.push(byte);
  }

  fun addString(string: String) {
    this.builder.append(string);
  }

  fun addLoc(loc: Loc) {
    this.addString(`${loc.start.line}:${loc.start.column}-${loc.end.line}:${loc.end.column}`);
  }

  fun addIndent() {
    this.addString(String.repeat("  ", this.indent));
  }

  fun visitNode(node: PrintNode) {
    match (node) {
      | Empty -> this.addString("None")
      | Int (int) -> this.addString(int.toString())
      | String (string) -> {
        this.addChar('"');
        this.addString(string);
        this.addChar('"');
      }
      | Bool (bool) -> this.addString(bool.toString())
      | Raw (raw) -> this.addString(raw)
      | List (nodes) -> {
        if (nodes.size == 0) {
          this.addString("[]");
        } else {
          this.addString("[\n");
          this.indent += 1;

          for (node in nodes) {
            this.addIndent();
            this.visitNode(node);
            this.addString(",\n");
          }

          this.indent -= 1;
          this.addIndent();
          this.addChar(']');
        }
      }
      | Node { name, loc, fields } -> {
        this.addString("{\n");
        this.indent += 1;

        // Add node type
        this.addIndent();
        this.addString("node: ");
        this.addString(name);
        this.addString(",\n");

        // Add loc
        this.addIndent();
        this.addString("loc: ");
        this.addLoc(loc);
        this.addString(",\n");

        // Add fields
        for ((name, node) in fields) {
          this.addIndent();
          this.addString(name);
          this.addString(": ");
          this.visitNode(node);
          this.addString(",\n");
        }

        this.indent -= 1;
        this.addIndent();
        this.addChar('}');
      }
    }
  }
}

fun optional<T>(x: Option<T>, f: (T) -> PrintNode): PrintNode =
  match (x) {
    | None -> Empty
    | Some (x) -> f(x)
  }

fun printModule(mod: ast.Module): String {
  val node = nodeOfModule(mod);
  val printer = Printer.new();
  printer.visitNode(node);

  return printer.builder;
}

fun nodeOfModule(mod: ast.Module): PrintNode {
  val ast.Module { loc, name, imports, toplevels, source: _ } = mod;
  return Node {
    name: "Module",
    loc,
    fields: [
      ("name", nodeOfModuleName(name)),
      ("imports", List (imports.map(nodeOfImport))),
      ("toplevels", List (toplevels.map(nodeOfToplevel))),
    ],
  };
}

fun nodeOfModuleName(name: ast.ModuleName): PrintNode {
  val ast.ModuleName { loc, name } = name;
  return Node { name: "ModuleName", loc, fields: [("name", nodeOfScopedIdentifier(name))] };
}

fun nodeOfImport(import_: ast.Import): PrintNode =
  match (import_) {
    | ast.ISimpleImport (i) -> nodeOfScopedIdentifier(i)
    | ast.IComplexImport (t) -> nodeOfComplexImport(t)
  }

fun nodeOfComplexImport(complex: ast.ComplexImport): PrintNode {
  val ast.ComplexImport { loc, scopes, aliases } = complex;
  return Node {
    name: "ComplexImport",
    loc,
    fields: [
      ("scopes", List (scopes.map(nodeOfIdentifier))),
      ("aliases", List (aliases.map(nodeOfImportAlias))),
    ],
  };
}

fun nodeOfImportAlias(alias_: ast.ImportAlias): PrintNode {
  val ast.ImportAlias { loc, name, alias_ } = alias_;
  return Node {
    name: "ImportAlias",
    loc,
    fields: [("name", nodeOfIdentifier(name)), ("alias", optional(alias_, nodeOfIdentifier))],
  };
}

fun nodeOfToplevel(toplevel: ast.Toplevel): PrintNode =
  match (toplevel) {
    | ast.TLFunction (t) -> nodeOfFunctionDeclaration(t)
    | ast.TLVariable (t) -> nodeOfVariableDeclaration(t)
    | ast.TLType (t) -> nodeOfTypeDeclaration(t)
    | ast.TLTrait (t) -> nodeOfTraitDeclaration(t)
  }

fun nodeOfFunctionDeclaration(decl: ast.FunctionDeclaration): PrintNode {
  val ast.FunctionDeclaration
    { loc, name, params, body, return_, typeParams, isBuiltin, isStatic, isOverride } = decl;
  val body = match (body) {
    | ast.FBBlock (block) -> nodeOfBlock(block)
    | ast.FBExpression (expr) -> nodeOfExpression(expr)
    | ast.FBSignature -> Empty
  };
  
  return Node {
    name: "Function",
    loc,
    fields: [
      ("name", nodeOfIdentifier(name)),
      ("params", List (params.map(nodeOfFunctionParam))),
      ("body", body),
      ("return", optional(return_, nodeOfType)),
      ("type_params", List (typeParams.map(nodeOfTypeParameter))),
      ("builtin", Bool (isBuiltin)),
      ("static", Bool (isStatic)),
      ("override", Bool (isOverride)),
    ]
  };
}

fun nodeOfFunctionParam(param: ast.FunctionParam): PrintNode {
  val ast.FunctionParam { loc, name, annot } = param;
  return Node {
    name: "Param",
    loc,
    fields: [("name", nodeOfIdentifier(name)), ("annot", nodeOfType(annot))],
  };
}

fun nodeOfTypeParameter(param: ast.TypeParameter): PrintNode {
  val ast.TypeParameter { loc, name, bounds } = param;
  return Node {
    name: "TypeParameter",
    loc,
    fields: [("name", nodeOfIdentifier(name)), ("bounds", List (bounds.map(nodeOfIdentifierType)))],
  };
}

fun nodeOfVariableDeclaration(decl: ast.VariableDeclaration): PrintNode {
  val ast.VariableDeclaration { loc, kind, pattern, init, annot } = decl;
  val kind = match (kind) {
    | ast.Immutable -> "Immutable"
    | ast.Mutable -> "Mutable"
  };

  return Node {
    name: "VariableDeclaration",
    loc,
    fields: [
      ("kind", Raw (kind)),
      ("pattern", nodeOfPattern(pattern)),
      ("init", nodeOfExpression(init)),
      ("annot", optional(annot, nodeOfType)),
    ],
 };
}

fun nodeOfTypeDeclaration(decl: ast.TypeDeclaration): PrintNode {
  val ast.TypeDeclaration { loc, name, typeParams, decl } = decl;
  val decl = match (decl) {
    | ast.TDAlias (typeAlias) -> ("alias", nodeOfType(typeAlias))
    | ast.TDTuple (tuple) -> ("tuple", nodeOfTupleDeclaration(tuple))
    | ast.TDRecord (record) -> ("record", nodeOfRecordDeclaration(record))
    | ast.TDVariant (variants) -> ("variants", List (variants.map(nodeOfVariantDeclaration)))
    | ast.TDBuiltin -> ("builtin", Bool (true))
  };

  return Node {
    name: "TypeDeclaration",
    loc,
    fields: [
      ("name", nodeOfIdentifier(name)),
      ("type_params", List (typeParams.map(nodeOfTypeParameter))),
      decl,
    ],
  };
}

fun nodeOfTupleDeclaration(decl: ast.TupleDeclaration): PrintNode {
  val ast.TupleDeclaration { loc, name, elements } = decl;
  return Node {
    name: "TupleVariant",
    loc,
    fields: [("name", nodeOfIdentifier(name)), ("elements", List (elements.map(nodeOfType)))],
  };
}

fun nodeOfRecordDeclaration(decl: ast.RecordDeclaration): PrintNode {
  val ast.RecordDeclaration { loc, name, fields } = decl;
  return Node {
    name: "RecordVariant",
    loc,
    fields: [
      ("name", nodeOfIdentifier(name)),
      ("fields", List (fields.map(nodeOfRecordDeclarationField))),
    ],
  };
}

fun nodeOfRecordDeclarationField(field: ast.RecordDeclarationField): PrintNode {
  val ast.RecordDeclarationField { loc, name, type_ } = field;
  return Node {
    name: "RecordVariantField",
    loc,
    fields: [("name", nodeOfIdentifier(name)), ("type", nodeOfType(type_))],
  };
}

fun nodeOfVariantDeclaration(decl: ast.VariantDeclaration): PrintNode =
  match (decl) {
    | ast.EnumVariant (ident) -> nodeOfIdentifier(ident)
    | ast.TupleVariant (tuple) -> nodeOfTupleDeclaration(tuple)
    | ast.RecordVariant (record) -> nodeOfRecordDeclaration(record)
  }

fun nodeOfTraitDeclaration(decl: ast.TraitDeclaration): PrintNode {
  val ast.TraitDeclaration { loc, kind, name, typeParams, implemented, methods_ } = decl;
  val kind = match (kind) {
    | ast.TKMethods -> "Methods"
    | ast.TKTrait -> "Trait"
  };

  return Node {
    name: "TraitDeclaration",
    loc,
    fields: [
      ("kind", Raw (kind)),
      ("name", nodeOfIdentifier(name)),
      ("type_params", List (typeParams.map(nodeOfTypeParameter))),
      ("implemented", List (implemented.map(nodeOfIdentifierType))),
      ("methods", List (methods_.map(nodeOfFunctionDeclaration))),
    ],
 };
}

fun nodeOfIdentifier(ident: ast.Identifier): PrintNode {
  val ast.Identifier { loc, name } = ident;
  return Node { name: "Identifier", loc, fields: [("name", String (name))] };
}

fun nodeOfScopedIdentifier(ident: ast.ScopedIdentifier): PrintNode {
  val ast.ScopedIdentifier { loc, scopes, name } = ident;
  return Node {
    name: "ScopedIdentifier",
    loc,
    fields: [("scopes", List (scopes.map(nodeOfIdentifier))), ("name", nodeOfIdentifier(name))],
  };
}

fun nodeOfStatement(stmt: ast.Statement): PrintNode =
  match (stmt) {
    | ast.SBlock (s) -> nodeOfBlock(s)
    | ast.SExpression (s) -> nodeOfExpressionStatement(s)
    | ast.SVariableDeclaration (s) -> nodeOfVariableDeclaration(s)
    | ast.SIf (s) -> nodeOfIf(s, true)
    | ast.SMatch (s) -> nodeOfMatch(s, true)
    | ast.SWhile (s) -> nodeOfWhile(s)
    | ast.SFor (s) -> nodeOfFor(s)
    | ast.SReturn (s) -> nodeOfReturn(s)
    | ast.SBreak (s) -> nodeOfBreak(s)
    | ast.SContinue (s) -> nodeOfContinue(s)
    | ast.SAssignment (s) -> nodeOfAssignment(s)
  }

fun nodeOfBlock(block: ast.Block): PrintNode {
  val ast.Block { loc, statements } = block;
  return Node {
    name: "Block",
    loc,
    fields: [("statements", List (statements.map(nodeOfStatement)))],
  };
}

fun nodeOfExpressionStatement(block: ast.ExpressionStatement): PrintNode {
  val ast.ExpressionStatement { loc, expr, isValue } = block;
  val fields = [("expression", nodeOfExpression(expr))];
  if (isValue) {
    fields.push(("is_value", Bool (true)));
  }

  return Node { name: "ExpressionStatement", loc, fields };
}

fun nodeOfIf(if_: ast.If, isStatement: Bool): PrintNode {
  val ast.If { loc, test, conseq, altern } = if_;
  val name = if (isStatement) {
    "IfStatement"
  } else {
    "IfExpression"
  };

  val altern = match (altern) {
    | ast.Else (block) -> nodeOfBlock(block)
    | ast.ElseIf (if_) -> nodeOfIf(if_, isStatement)
    | ast.NoAltern -> Empty
  };

  return Node {
    name,
    loc,
    fields: [
      ("test", nodeOfExpression(test)),
      ("conseq", nodeOfBlock(conseq)),
      ("altern", altern),
    ],
  };
}  


fun nodeOfMatch(match_: ast.Match, isStatement: Bool): PrintNode {
  val ast.Match { loc, args, cases } = match_;
  val name = if (isStatement) {
    "MatchStatement"
  } else {
    "MatchExpression"
  };

  return Node {
    name,
    loc,
    fields: [
      ("args", List (args.map(nodeOfExpression))),
      ("cases", List (cases.map(nodeOfMatchCase))),
    ],
  };
}

fun nodeOfMatchCase(case: ast.MatchCase): PrintNode {
  val ast.MatchCase { loc, pattern, guard, body } = case;
  val body = match (body) {
    | ast.MCStatement (stmt) -> nodeOfStatement(stmt)
    | ast.MCExpression (expr) -> nodeOfExpression(expr)
  };

  return Node {
    name: "MatchCase",
    loc,
    fields: [
      ("pattern", nodeOfPattern(pattern)),
      ("guard", optional(guard, nodeOfExpression)),
      ("right", body),
    ],
  };
}  

fun nodeOfWhile(w: ast.While): PrintNode {
  val ast.While { loc, test, body } = w;
  return Node {
    name: "While",
    loc,
    fields: [("test", nodeOfExpression(test)), ("body", nodeOfBlock(body))],
  };
}

fun nodeOfFor(w: ast.For): PrintNode {
  val ast.For { loc, pattern, annot, iterator, body } = w;
  return Node {
    name: "For",
    loc,
    fields: [
      ("pattern", nodeOfPattern(pattern)),
      ("annot", optional(annot, nodeOfType)),
      ("iterator", nodeOfExpression(iterator)),
      ("body", nodeOfBlock(body)),
    ],
  };
}

fun nodeOfReturn(r: ast.Return): PrintNode {
  val ast.Return { loc, arg } = r;
  return Node { name: "Return", loc, fields: [("arg", optional(arg, nodeOfExpression))] };
}

fun nodeOfBreak(b: ast.Break): PrintNode {
  val ast.Break { loc } = b;
  return Node { name: "Break", loc, fields: [] };
}


fun nodeOfContinue(b: ast.Continue): PrintNode {
  val ast.Continue { loc } = b;
  return Node { name: "Continue", loc, fields: [] };
}

fun nodeOfAssignment(assign: ast.Assignment): PrintNode {
  val ast.Assignment { loc, op, lvalue, expr } = assign;

  val op = match (op) {
    | None -> Empty
    | Some (op) -> {
      val string = match (op) {
        | ast.AssignAdd -> "Add"
        | ast.AssignSubtract -> "Subtract"
        | ast.AssignMultiply -> "Multiply"
        | ast.AssignDivide -> "Divide"
        | ast.AssignRemainder -> "Remainder"
        | ast.AssignBitwiseAnd -> "BitwiseAnd"
        | ast.AssignBitwiseOr -> "BitwiseOr"
        | ast.AssignBitwiseXor -> "BitwiseXor"
        | ast.AssignLeftShift -> "LeftShift"
        | ast.AssignArithmeticRightShift -> "ArithmeticRightShift"
        | ast.AssignLogicalRightShift -> "LogicalRightShift"
      };

      String (string)
    }
  };

  val lvalue = match (lvalue) {
    | ast.ALPattern (patt) -> nodeOfPattern(patt)
    | ast.ALExpression (expr) -> nodeOfExpression(expr)
  };

  return Node {
    name: "Assignment",
    loc,
    fields: [("op", op), ("lvalue", lvalue), ("expr", nodeOfExpression(expr))],
  };
}

fun nodeOfExpression(expr: ast.Expression): PrintNode =
  match (expr) {
    | ast.EUnitLiteral (e) -> nodeOfUnitLiteral(e)
    | ast.EIntLiteral (e) -> nodeOfIntLiteral(e)
    | ast.EBoolLiteral (e) -> nodeOfBoolLiteral(e)
    | ast.EStringLiteral (e) -> nodeOfStringLiteral(e)
    | ast.ECharLiteral (e) -> nodeOfCharLiteral(e)
    | ast.EInterpolatedString (e) -> nodeOfInterpolatedString(e)
    | ast.EIdentifier (e) -> nodeOfIdentifier(e)
    | ast.EScopedIdentifier (e) -> nodeOfScopedIdentifier(e)
    | ast.ETuple (e) -> nodeOfTupleExpression(e)
    | ast.ERecord (e) -> nodeOfRecordExpression(e)
    | ast.ETypeCast (e) -> nodeOfTypeCast(e)
    | ast.ECall (e) -> nodeOfCall(e)
    | ast.EUnaryOperation (e) -> nodeOfUnaryOperation(e)
    | ast.EBinaryOperation (e) -> nodeOfBinaryOperation(e)
    | ast.ELogicalAnd (e) -> nodeOfLogicalAnd(e)
    | ast.ELogicalOr (e) -> nodeOfLogicalOr(e)
    | ast.ENamedAccess (e) -> nodeOfNamedAccess(e)
    | ast.EIndexedAccess (e) -> nodeOfIndexedAccess(e)
    | ast.EUnwrap (e) -> nodeOfUnwrap(e)
    | ast.EIf (e) -> nodeOfIf(e, false)
    | ast.EMatch (e) -> nodeOfMatch(e, false)
    | ast.EVecLiteral (e) -> nodeOfVecLiteral(e)
    | ast.EMapLiteral (e) -> nodeOfMapLiteral(e)
    | ast.ESetLiteral (e) -> nodeOfSetLiteral(e)
    | ast.EAnonymousFunction (e) -> nodeOfAnonymousFunction(e)
  }

fun nodeOfUnitLiteral(lit: ast.UnitLiteral): PrintNode {
  val ast.UnitLiteral { loc } = lit;
  return Node { name: "Unit", loc, fields: [] };
}

fun nodeOfIntLiteral(lit: ast.IntLiteral): PrintNode {
  val ast.IntLiteral { loc, raw, base } = lit;
  val fields = [("raw", String (raw))];
  match (base) {
    | ast.Dec -> ()
    | ast.Bin -> fields.push(("base", String ("Bin")))
    | ast.Hex -> fields.push(("base", String ("Hex")))
  }

  return Node { name: "IntLiteral", loc, fields };
}

fun nodeOfBoolLiteral(lit: ast.BoolLiteral): PrintNode {
  val ast.BoolLiteral { loc, value } = lit;
  return Node { name: "BoolLiteral", loc, fields: [("value", Bool (value))] };
}

fun nodeOfStringLiteral(lit: ast.StringLiteral): PrintNode {
  val ast.StringLiteral { loc, value } = lit;
  return Node { name: "StringLiteral", loc, fields: [("value", String (value))] };
}

fun nodeOfCharLiteral(lit: ast.CharLiteral): PrintNode {
  val ast.CharLiteral { loc, value } = lit;
  return Node {
    name: "CharLiteral",
    loc,
    fields: [("value", String (escapeCharLiteralValue(value)))] };
}

fun nodeOfInterpolatedString(string: ast.InterpolatedString): PrintNode {
  val ast.InterpolatedString { loc, parts } = string;
  return Node {
    name: "InterpolatedString",
    loc,
    fields: [("parts", List (parts.map(nodeOfInterpolatedStringPart)))],
  };
}

fun nodeOfInterpolatedStringPart(part: ast.InterpolatedStringPart): PrintNode =
  match (part) {
    | ast.IPString (string) -> nodeOfStringLiteral(string)
    | ast.IPExpression (expr) -> nodeOfExpression(expr)
  }

fun nodeOfTupleExpression(tuple: ast.TupleExpression): PrintNode {
  val ast.TupleExpression { loc, elements } = tuple;
  return Node {
    name: "TupleExpression",
    loc,
    fields: [("elements", List (elements.map(nodeOfExpression)))],
  };
}

fun nodeOfRecordExpression(decl: ast.RecordExpression): PrintNode {
  val ast.RecordExpression { loc, name, fields, rest: _ } = decl;
  return Node {
    name: "RecordExpression",
    loc,
    fields: [
      ("name", nodeOfExpression(name)),
      ("fields", List (fields.map(nodeOfRecordExpressionField))),
    ],
  };
}

fun nodeOfRecordExpressionField(field: ast.RecordExpressionField): PrintNode {
  val ast.RecordExpressionField { loc, name, value } = field;
  return Node {
    name: "RecordExpressionField",
    loc,
    fields: [("name", nodeOfIdentifier(name)), ("value", optional(value, nodeOfExpression))],
  };
}

fun nodeOfTypeCast(tuple: ast.TypeCast): PrintNode {
  val ast.TypeCast { loc, expr, type_ } = tuple;
  return Node {
    name: "TypeCast",
    loc,
    fields: [("expr", nodeOfExpression(expr)), ("type", nodeOfType(type_))],
  };
}

fun nodeOfCall(call: ast.Call): PrintNode {
  val ast.Call { loc, func, args } = call;
  return Node {
    name: "Call",
    loc,
    fields: [("func", nodeOfExpression(func)), ("args", List (args.map(nodeOfExpression)))],
  };
}

fun nodeOfUnaryOperation(unary: ast.UnaryOperation): PrintNode {
  val ast.UnaryOperation { loc, op, operand } = unary;
  val op = match (op) {
    | ast.UnaryPlus -> "Plus"
    | ast.UnaryMinus -> "Minus"
    | ast.UnaryNot -> "Not"
  };

  return Node {
    name: "UnaryOperation",
    loc,
    fields: [("op", Raw (op)), ("operand", nodeOfExpression(operand))],
  };
}

fun nodeOfBinaryOperation(binary: ast.BinaryOperation): PrintNode {
  val ast.BinaryOperation { loc, op, left, right } = binary;
  val op = match (op) {
    | ast.BinaryAdd -> "Add"
    | ast.BinarySubtract -> "Subtract"
    | ast.BinaryMultiply -> "Multiply"
    | ast.BinaryDivide -> "Divide"
    | ast.BinaryRemainder -> "Remainder"
    | ast.BinaryEqual -> "Equal"
    | ast.BinaryNotEqual -> "NotEqual"
    | ast.BinaryLessThan -> "LessThan"
    | ast.BinaryGreaterThan -> "GreaterThan"
    | ast.BinaryLessThanOrEqual -> "LessThanOrEqual"
    | ast.BinaryGreaterThanOrEqual -> "GreaterThanOrEqual"
    | ast.BinaryBitwiseAnd -> "BitwiseAnd"
    | ast.BinaryBitwiseOr -> "BitwiseOr"
    | ast.BinaryBitwiseXor -> "BitwiseXor"
    | ast.BinaryLeftShift -> "LeftShift"
    | ast.BinaryArithmeticRightShift -> "ArithmeticRightShift"
    | ast.BinaryLogicalRightShift -> "LogicalRightShift"
  };

  return Node {
    name: "BinaryOperation",
    loc,
    fields: [
      ("op", Raw (op)),
      ("left", nodeOfExpression(left)),
      ("right", nodeOfExpression(right)),
    ],
  };
}

fun nodeOfLogicalAnd(logical: ast.LogicalAnd): PrintNode {
  val ast.LogicalAnd { loc, left, right } = logical;
  return Node {
    name: "LogicalAnd",
    loc,
    fields: [("left", nodeOfExpression(left)), ("right", nodeOfExpression(right))],
  };
}

fun nodeOfLogicalOr(logical: ast.LogicalOr): PrintNode {
  val ast.LogicalOr { loc, left, right } = logical;
  return Node {
    name: "LogicalOr",
    loc,
    fields: [("left", nodeOfExpression(left)), ("right", nodeOfExpression(right))],
  };
}

fun nodeOfNamedAccess(access: ast.NamedAccess): PrintNode {
  val ast.NamedAccess { loc, target, name } = access;
  return Node {
    name: "NamedAccess",
    loc,
    fields: [("target", nodeOfExpression(target)), ("name", nodeOfIdentifier(name))],
  };
}

fun nodeOfIndexedAccess(access: ast.IndexedAccess): PrintNode {
  val ast.IndexedAccess { loc, target, index } = access;
  return Node {
    name: "IndexedAccess",
    loc,
    fields: [("target", nodeOfExpression(target)), ("index", nodeOfExpression(index))],
  };
}

fun nodeOfUnwrap(unwrap: ast.Unwrap): PrintNode {
  val ast.Unwrap { loc, operand } = unwrap;
  return Node { name: "Unwrap", loc, fields: [("operand", nodeOfExpression(operand))]};
}

fun nodeOfVecLiteral(lit: ast.VecLiteral): PrintNode {
  val ast.VecLiteral { loc, elements } = lit;
  return Node {
    name: "VecLiteral",
    loc,
    fields: [("elements", List (elements.map(nodeOfExpression)))],
  };
}

fun nodeOfMapLiteral(lit: ast.MapLiteral): PrintNode {
  val ast.MapLiteral { loc, entries } = lit;
  return Node {
    name: "MapLiteral",
    loc,
    fields: [("entries", List (entries.map(nodeOfMapLiteralEntry)))],
  };
}

fun nodeOfMapLiteralEntry(access: ast.MapLiteralEntry): PrintNode {
  val ast.MapLiteralEntry { loc, key, value } = access;
  return Node {
    name: "MapLiteralEntry",
    loc,
    fields: [("key", nodeOfExpression(key)), ("value", nodeOfExpression(value))],
  };
}

fun nodeOfSetLiteral(lit: ast.SetLiteral): PrintNode {
  val ast.SetLiteral { loc, elements } = lit;
  return Node {
    name: "SetLiteral",
    loc,
    fields: [("elements", List (elements.map(nodeOfExpression)))],
  };
}

fun nodeOfAnonymousFunction(func: ast.AnonymousFunction): PrintNode {
  val ast.AnonymousFunction { loc, params, return_, body } = func;
  val body = match (body) {
    | ast.ABBlock (block) -> nodeOfBlock(block)
    | ast.ABExpression (expr) -> nodeOfExpression(expr)
  };
  
  return Node {
    name: "AnonymousFunction",
    loc,
    fields: [
      ("params", List (params.map(nodeOfAnonymousFunctionParam))),
      ("return", optional(return_, nodeOfType)),
      ("body", body),
    ]
  };
}

fun nodeOfAnonymousFunctionParam(param: ast.AnonymousFunctionParam): PrintNode {
  val ast.AnonymousFunctionParam { loc, name, annot } = param;
  return Node {
    name: "Param",
    loc,
    fields: [("name", nodeOfIdentifier(name)), ("annot", optional(annot, nodeOfType))],
  };
}

fun nodeOfType(ty: ast.Type): PrintNode =
  match (ty) {
    | ast.TIdentifier (t) -> nodeOfIdentifierType(t)
    | ast.TTuple (t) -> nodeOfTupleType(t)
    | ast.TFunction (t) -> nodeOfFunctionType(t)
    | ast.TTrait (t) -> nodeOfTraitType(t)
  }

fun nodeOfIdentifierType(ident: ast.IdentifierType): PrintNode {
  val ast.IdentifierType { loc, name, typeArgs } = ident;
  return Node {
    name: "IdentifierType",
    loc,
    fields: [
      ("name", nodeOfScopedIdentifier(name)),
      ("type_args", List (typeArgs.map(nodeOfType))),
    ],
  };
}

fun nodeOfTupleType(tuple: ast.TupleType): PrintNode {
  val ast.TupleType { loc, elements } = tuple;
  return Node { name: "TupleType", loc, fields: [("elements", List (elements.map(nodeOfType)))] };
}

fun nodeOfFunctionType(func: ast.FunctionType): PrintNode {
  val ast.FunctionType { loc, params, return_ } = func;
  return Node {
    name: "FunctionType",
    loc, fields: [("params", List (params.map(nodeOfType))), ("return", nodeOfType(return_))] };
}

fun nodeOfTraitType(trait_: ast.TraitType): PrintNode {
  val ast.TraitType { loc, trait_ } = trait_;
  return Node { name: "TraitType", loc, fields: [("trait", nodeOfIdentifierType(trait_))] };
}

fun nodeOfPattern(pattern: ast.Pattern): PrintNode =
  match (pattern) {
    | ast.PIdentifier (p) -> nodeOfScopedIdentifier(p)
    | ast.PWildcard (p) -> nodeOfWildcard(p)
    | ast.PNamedWildcard (p) -> nodeOfNamedWildcard(p)
    | ast.PBinding (p) -> nodeOfBindingPattern(p)
    | ast.POr (p) -> nodeOfOrPattern(p)
    | ast.PTuple (p) -> nodeOfTuplePattern(p)
    | ast.PRecord (p) -> nodeOfRecordPattern(p)
    | ast.PLiteral (p) -> nodeOfLiteralPattern(p)
  }

fun nodeOfWildcard(loc: Loc): PrintNode = Node { name: "Wildcard", loc, fields: [] }

fun nodeOfNamedWildcard(patt: ast.NamedWildcard): PrintNode {
  val ast.NamedWildcard { loc, name } = patt;
  return Node { name: "NamedWildcard", loc, fields: [("name", nodeOfScopedIdentifier(name))] };
}

fun nodeOfBindingPattern(patt: ast.BindingPattern): PrintNode {
  val ast.BindingPattern { loc, pattern, name } = patt;
  return Node {
    name: "Binding",
    loc, fields:
    [("pattern", nodeOfPattern(pattern)), ("name", nodeOfIdentifier(name))],
  };
}

fun nodeOfOrPattern(patt: ast.OrPattern): PrintNode {
  val ast.OrPattern { loc, left, right } = patt;
  return Node {
    name: "Or",
    loc,
    fields: [("left", nodeOfPattern(left)), ("right", nodeOfPattern(right))],
  };
}

fun nodeOfTuplePattern(decl: ast.TuplePattern): PrintNode {
  val ast.TuplePattern { loc, name, elements } = decl;
  return Node {
    name: "TuplePattern",
    loc,
    fields: [
      ("name", optional(name, nodeOfScopedIdentifier)),
      ("elements", List (elements.map(nodeOfPattern))),
    ],
  };
}

fun nodeOfRecordPattern(decl: ast.RecordPattern): PrintNode {
  val ast.RecordPattern { loc, name, fields, rest } = decl;
  return Node {
    name: "RecordPattern",
    loc,
    fields: [
      ("name", nodeOfScopedIdentifier(name)),
      ("fields", List (fields.map(nodeOfRecordPatternField))),
      ("rest", Bool (rest)),
    ],
  };
}

fun nodeOfRecordPatternField(field: ast.RecordPatternField): PrintNode {
  val ast.RecordPatternField { loc, name, value } = field;
  return Node {
    name: "RecordPatternField",
    loc,
    fields: [("name", optional(name, nodeOfIdentifier)), ("value", nodeOfPattern(value))],
  };
}

fun nodeOfLiteralPattern(lit: ast.LiteralPattern): PrintNode =
  match (lit) {
    | ast.PUnit (lit) -> nodeOfUnitLiteral(lit)
    | ast.PBool (lit) -> nodeOfBoolLiteral(lit)
    | ast.PInt (lit) -> nodeOfIntLiteral(lit)
    | ast.PChar (lit) -> nodeOfCharLiteral(lit)
    | ast.PString (lit) -> nodeOfStringLiteral(lit)
  }
