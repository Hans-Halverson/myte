module myte.parse.error

import std.io.print
import std.string.ToString
import std.sys.exit

import myte.common.error.formatErrorWithLoc
import myte.common.loc.Loc
import myte.parse.token
import myte.parse.token.Token

type ParseError =
  | UnknownToken { raw: String }
  | UnexpectedToken { actual: Token, expected: Option<Token> }
  | UnterminatedStringLiteral
  | MalformedToplevel { token: Token }
  | MalformedFunctionBody { token: Token }
  | MalformedTypeDeclaration { token: Token }
  | MalformedType { token: Token }
  | EmptyRecord
  | EmptyTuple
  | SingleVariant
  | TypeAliasBuiltin
  | CannotOpenFile { filename: String }

fun fatal(error: ParseError, loc: Loc): Never {
  print(formatErrorWithLoc(error.toString(), loc));
  exit(1);
}

methods ParseError {
  implements ToString

  override fun toString(): String =
    match (this) {
      | UnknownToken { raw } -> `Unexpected token \`${raw}\``
      | UnexpectedToken { actual: token.Eof, expected: None } -> "Unexpected <EOF>"
      | UnexpectedToken { actual, expected: None } -> `Unexpected token \`${actual}\``
      | UnexpectedToken { actual, expected: Some (token.Identifier _) } ->
        `Unexpected token \`${actual}\`, expected identifier`
      | UnexpectedToken { actual, expected: Some (expected) } ->
        `Unexpected token \`${actual}\`, expected \`${expected}\``
      | UnterminatedStringLiteral -> "Unterminated string literal"
      | MalformedToplevel { token } ->
        `Unexpected token \`${token}\`, expected start of top level declaration`
      | MalformedFunctionBody { token } ->
        `Unexpected token \`${token}\`, expected expected start of function body`
      | MalformedTypeDeclaration { token } ->
        `Unexpected token \`${token}\`, expected expected start of type declaration`
      | MalformedType { token } -> `Unexpected token \`${token}\`, expected start of type`
      | EmptyRecord -> "Record must have at least one field"
      | EmptyTuple -> "Tuple must have at least one element"
      | SingleVariant -> "Variant type must have at least two variants"
      | TypeAliasBuiltin ->
        "A type alias cannot be builtin. Only function and type declarations can be builtin."
      | CannotOpenFile { filename } -> `Cannot open file ${filename}`
    }
}