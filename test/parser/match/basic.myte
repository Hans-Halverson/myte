module test

fun optionalLeadingPipe() {
  // Without leading pipe
  match (x) {
      a -> a
  }

  match (x) {
      a -> a
    | b -> b
    | c -> c
  }

  // With leading pipe
  match (x) {
    | a -> a
  }

  match (x) {
    | a -> a
    | b -> b
    | c -> c
  }
}

fun matchExpression() {
  val x = match (x) {
    | a -> a
  };
}

fun multipleArgs() {
  match (x, 1 + 2, foo()) {
    | a -> a
  }
}

fun argsTrailingComma() {
  match (x,) {
    | a -> a
  }

  match (x, y, z,) {
    | a -> a
  }
}

fun guards() {
  match (x) {
    | a when a > 1 -> a
    | b -> b
    | c when c > 1 -> c
  }
}

fun complexPatterns() {
  match (x) {
    | (a, b, c) -> 1
    | Tup (d, e) -> 2
    | Rec { field } -> 3
  }
}

fun literalsInPatterns() {
  match (x) {
    | () -> a
    | true -> b
    | 1 -> c
    | "" -> d
  }
}

fun rightHandExpression() {
  match (x) {
    | a -> 1 + a * 2
  }
}

fun rightHandStatements() {
  // All statements allowed on the right hand side of match cases
  match (x) {
    | a -> { 1; }
    | b -> if (true) { 1; } else { 2; }
    | c -> while (true) { 1; }
    | d -> return
    | e -> return 1
    | f -> break
    | g -> continue
    | h -> for (x in y) { 1; }
  }

  // Handle return without argument at end
  match (x) {
    | a -> return
  }
}

fun nestedMatches() {
  // Nested match statements
  match (x) {
    | _ -> match (y) {
      | _ -> match (z) {
        | _ -> {}  
      }
    }
  }

  // Nested match expressions
  val a = match (x) {
    | _ -> match (y) {
      | _ -> match (z) {
        | _ -> ()
      }
    }
  };

  // Match expression within match statement
  match (x) {
    | _ -> (match (y) {
      | _ -> match (z) {
        | _ -> ()
      }
    })
  }
}

fun nestedIfInMatch() {
  // If in match statement is a statement
  match (x) {
    | _ -> if (y) {} else {}
  }

  // If in match expression is an expression
  val x = match (x) {
    | _ -> if (x) { y } else { z }
  };
}