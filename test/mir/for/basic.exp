func unit @test.use<Bool>(bool %0) {
  Ret
}

func unit @test.use<Byte>(byte %1) {
  Ret
}

func unit @test.use<Function>(fn %2) {
  Ret
}

func unit @test.use<Int>(int %3) {
  Ret
}

func unit @test.testIterators(std.vec.Vec<Int>* %4, std.vec.Vec<Bool>* %5) {
  %6 := Call std.vec.VecIterator<Int>* @std.vec.Vec.toIterator<Int>(%4)
  continue @0
label @0:
  %7 := Call std.option.Option<Int>* @std.vec.VecIterator.next<Int>(%6)
  %8 := Load byte %7
  %9 := Eq byte %8, 1
  branch %9, @1, @2
label @1:
  %10 := GetPointer int, std.option.Option<Int>::Some* %7.2
  %11 := Load int %10
  %12 := Call unit @test.use<Int>(%11)
  continue @0
label @2:
  %13 := Call std.vec.VecIterator<Bool>* @std.vec.Vec.toIterator<Bool>(%5)
  continue @3
label @3:
  %15 := Phi bool @2:false, @4:%14
  %16 := Call std.option.Option<Bool>* @std.vec.VecIterator.next<Bool>(%13)
  %17 := Load byte %16
  %18 := Eq byte %17, 1
  branch %18, @4, @5
label @4:
  %19 := GetPointer bool, std.option.Option<Bool>::Some* %16.1
  %14 := Load bool %19
  %20 := Call unit @test.use<Bool>(%14)
  continue @3
label @5:
  %21 := Call unit @test.use<Bool>(%15)
  Ret
}

func unit @test.testBreak(std.vec.Vec<Bool>* %22) {
  %23 := Call std.vec.VecIterator<Bool>* @std.vec.Vec.toIterator<Bool>(%22)
  continue @6
label @6:
  %24 := Phi int @test.testBreak:0, @8:2
  %25 := Call std.option.Option<Bool>* @std.vec.VecIterator.next<Bool>(%23)
  %26 := Load byte %25
  %27 := Eq byte %26, 1
  branch %27, @7, @10
label @7:
  %28 := GetPointer bool, std.option.Option<Bool>::Some* %25.1
  %29 := Load bool %28
  %30 := LogNot %29
  branch %30, @9, @8
label @8:
  %31 := Call unit @test.use<Int>(2)
  continue @6
label @9:
  %32 := Call unit @test.use<Int>(1)
  continue @10
label @10:
  %33 := Phi int @6:%24, @9:1
  %34 := Call unit @test.use<Int>(%33)
  Ret
}

func unit @test.testContinue(std.vec.Vec<Bool>* %35) {
  %36 := Call std.vec.VecIterator<Bool>* @std.vec.Vec.toIterator<Bool>(%35)
  continue @11
label @11:
  %37 := Phi int @test.testContinue:0, @13:1, @14:2
  %38 := Call std.option.Option<Bool>* @std.vec.VecIterator.next<Bool>(%36)
  %39 := Load byte %38
  %40 := Eq byte %39, 1
  branch %40, @12, @15
label @12:
  %41 := GetPointer bool, std.option.Option<Bool>::Some* %38.1
  %42 := Load bool %41
  %43 := LogNot %42
  branch %43, @13, @14
label @13:
  %44 := Call unit @test.use<Int>(1)
  continue @11
label @14:
  %45 := Call unit @test.use<Int>(2)
  continue @11
label @15:
  %46 := Call unit @test.use<Int>(%37)
  Ret
}

func unit @test.testStringIterator(std.string.String* %47) {
  %48 := Call std.string.StringByteIterator* @std.string.String.bytes(%47)
  %49 := Call std.string.StringByteIterator* @std.iterator.Iterator.toIterator<std.string.StringByteIterator,Byte>(%48)
  continue @16
label @16:
  %50 := Call std.option.Option<Byte>* @std.string.StringByteIterator.next(%49)
  %51 := Load byte %50
  %52 := Eq byte %51, 1
  branch %52, @17, @18
label @17:
  %53 := GetPointer byte, std.option.Option<Byte>::Some* %50.1
  %54 := Load byte %53
  %55 := Call unit @test.use<Byte>(%54)
  continue @16
label @18:
  Ret
}

func int @test.main() {
  %56 := Call unit @test.use<Function>(@test.testIterators)
  %57 := Call unit @test.use<Function>(@test.testBreak)
  %58 := Call unit @test.use<Function>(@test.testContinue)
  %59 := Call unit @test.use<Function>(@test.testStringIterator)
  Ret 0
}