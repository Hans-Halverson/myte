module test

fun use<T>(x: T): T = x

fun useByte(x: Byte): Byte = x

fun useLong(x: Long): Long = x

fun unit(): Unit = ()

val NaN: Double = 0.0 / 0.0

fun testInt() {
  use(-(56));

  use(1 + 2);
  use(1 - 2);
  use(2 * 7);
  use(24 / 3);
  use(19 % 3);
  use(0b1100 & 0b1010);
  use(0b1100 | 0b1010);
  use(0b1100 ^ 0b1010);
  use(1 << 4);
  use(-1 >> 2);
  use(-1 >>> 2);

  use((5: Int) > 7);
}

fun testByte() {
  useByte(-(56));

  useByte(1 + 2);
  useByte(1 - 2);
  useByte(2 * 7);
  useByte(24 / 3);
  useByte(19 % 3);
  useByte(0b1100 & 0b1010);
  useByte(0b1100 | 0b1010);
  useByte(0b1100 ^ 0b1010);
  useByte(1 << 4);
  useByte(1 << 7);
  useByte(-1 >> 2);
  useByte(-1 >>> 2);

  use((5: Byte) > 7);

  // Byte overflow
  useByte(-(-128));
  useByte(125 + 3);
  useByte(-128 - 3);
  useByte(127 * 3);
}

fun testLong() {
  useLong(-(56));

  useLong(1 + 2);
  useLong(1 - 2);
  useLong(2 * 7);
  useLong(24 / 3);
  useLong(19 % 3);
  useLong(0b1100 & 0b1010);
  useLong(0b1100 | 0b1010);
  useLong(0b1100 ^ 0b1010);
  useLong(1 << 4);
  useLong(1 << 63);
  useLong(-1 >> 2);
  useLong(-1 >>> 2);

  use((5: Long) > 7);
}

fun testDouble() {
  use(-(56.0));

  use(1.1 + 2.1);
  use(1.1 - 2.2);
  use(2.1 * 7.1);
  use(24.1 / 3.1);

  use(5.0 > 7.0);

  // Special values
  use(NaN == NaN);
  use(NaN != NaN);
}

fun testBool() {
  use(!true);

  use(true && false);
  use(true || false);
  use(true == false);
  use(true != false);
}

// Unit constants are not folded as they are removed during MIR emission. Instead calls to
// std.unit.Unit.equals are emitted.
fun testUnit() {
  use(() == ());
  use(() != ());
  use(unit() == unit());
  use(unit() != unit());
}

@(Inline)
fun matchNone(x: Option<String>): Int =
  match (x) {
    | None -> 3
    | Some _ -> 5
  }

fun testNullPointer() {
  use(matchNone(None));
}

// Shifts only use lowest byte of right hand side
fun testShift() {
  use(1 << 258);
  use(1 << 258);
}

fun main() {
  testDouble();
}