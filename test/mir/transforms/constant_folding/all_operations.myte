module test

fun use<T>(x: T): T = x

fun unit(): Unit = ()

fun testInt() {
  use(-(56));

  use(1 + 2);
  use(1 - 2);
  use(2 * 7);
  use(24 / 3);
  use(19 % 3);
  use(0b1100 & 0b1010);
  use(0b1100 | 0b1010);
  use(0b1100 ^ 0b1010);
  use(1 << 4);
  use(-1 >> 2);
  use(-1 >>> 2);

  use((5: Int) > 7);
}

fun testByte() {
  use(-(56));

  use(1 + 2);
  use(1 - 2);
  use(2 * 7);
  use(24 / 3);
  use(19 % 3);
  use(0b1100 & 0b1010);
  use(0b1100 | 0b1010);
  use(0b1100 ^ 0b1010);
  use(1 << 4);
  use(-1 >> 2);
  use(-1 >>> 2);

  use((5: Byte) > 7);
}

fun testLong() {
  use(-(56));

  use(1 + 2);
  use(1 - 2);
  use(2 * 7);
  use(24 / 3);
  use(19 % 3);
  use(0b1100 & 0b1010);
  use(0b1100 | 0b1010);
  use(0b1100 ^ 0b1010);
  use(1 << 4);
  use(-1 >> 2);
  use(-1 >>> 2);

  use((5: Long) > 7);
}

fun testDouble() {
  use(-(56.0));

  use(1.1 + 2.1);
  use(1.1 - 2.2);
  use(2.1 * 7.1);
  use(24.1 / 3.1);

  use(5.0 > 7.0);
}

fun testBool() {
  use(!true);

  use(true && false);
  use(true || false);
  use(true == false);
  use(true != false);
}

// Unit constants are not folded as they are removed during MIR emission. Instead calls to
// std.unit.Unit.equals are emitted.
fun testUnit() {
  use(() == ());
  use(() != ());
  use(unit() == unit());
  use(unit() != unit());
}

// Shifts only use lowest byte of right hand side
fun testShift() {
  use(1 << 258);
  use(1 << 258);
}

fun main() {
  testDouble();
}