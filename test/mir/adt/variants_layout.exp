type test.Opt1 {byte, byte[7]}

type test.Opt1::Some1 {byte, byte[3], int}

func void @test.useOpt1(test.Opt1* %0) {
  Ret
}

type test.Opt2<Bool> {byte, byte[1]}

type test.Opt2<Int> {byte, byte[7]}

type test.Opt2<String> {byte, byte[15]}

type test.Opt2<test.Opt2<String>> {byte, byte[15]}

type test.Opt2<Bool>::Some2 {byte, bool}

type test.Opt2<Int>::Some2 {byte, byte[3], int}

type test.Opt2<String>::Some2 {byte, byte[7], std.string.String*}

type test.Opt2<test.Opt2<String>>::Some2 {byte, byte[7], test.Opt2<String>*}

func void @test.useOpt2(test.Opt2<Int>* %0, test.Opt2<Bool>* %1, test.Opt2<test.Opt2<String>>* %2) {
  Ret
}

type test.V1 {byte, byte[23]}

type test.V1::V1Tup1 {byte, byte, byte[2], int, test.Opt1*, byte[8]}

type test.V1::V1Tup2 {byte, byte, byte, byte, int, test.Opt1*, byte[8]}

type test.V1::V2Rec1 {byte, byte, byte[2], int, test.Opt1*, test.Opt2<Int>*}

type test.V1::V2Rec2 {byte, byte, byte, byte[1], int, int, byte[12]}

func void @test.useV1(test.V1* %0) {
  Ret
}

func void @test.use<Function>(fn %0) {
  Ret
}

func int @test.main() {
  Call void @test.use<Function>(@test.useOpt1)
  Call void @test.use<Function>(@test.useOpt2)
  Call void @test.use<Function>(@test.useV1)
  Ret 0
}