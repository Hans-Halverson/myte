type test.Opt1 {byte, byte[7]}

type test.Opt1::Some1 {byte, byte[3], int}

func unit @test.useOpt1(test.Opt1* %0) {
  Ret
}

type test.Opt2<Bool> {byte, byte[1]}

type test.Opt2<Int> {byte, byte[7]}

type test.Opt2<String> {byte, byte[15]}

type test.Opt2<test.Opt2<String>> {byte, byte[15]}

type test.Opt2<Bool>::Some2 {byte, bool}

type test.Opt2<Int>::Some2 {byte, byte[3], int}

type test.Opt2<String>::Some2 {byte, byte[7], std.string.String*}

type test.Opt2<test.Opt2<String>>::Some2 {byte, byte[7], test.Opt2<String>*}

func unit @test.useOpt2(test.Opt2<Int>* %1, test.Opt2<Bool>* %2, test.Opt2<test.Opt2<String>>* %3) {
  Ret
}

type test.V1 {byte, byte[23]}

type test.V1::V1Tup1 {byte, byte, byte[2], int, test.Opt1*, byte[8]}

type test.V1::V1Tup2 {byte, byte, byte, byte, int, test.Opt1*, byte[8]}

type test.V1::V2Rec1 {byte, byte[7], test.Opt1*, int, byte, byte[3]}

type test.V1::V2Rec2 {byte, byte, byte[2], int, byte, byte[15]}

func unit @test.useV1(test.V1* %4) {
  Ret
}

func unit @test.use<Function>(fn %5) {
  Ret
}

func int @test.main() {
  %6 := Call unit @test.use<Function>(@test.useOpt1)
  %7 := Call unit @test.use<Function>(@test.useOpt2)
  %8 := Call unit @test.use<Function>(@test.useV1)
  Ret 0
}