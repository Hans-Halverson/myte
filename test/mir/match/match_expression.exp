func void @test.testMatchExpressionBlockValues(long %0) {
  %1 := Eq long %0, 1
  branch %1, @1, @0
label @0:
  continue @1
label @1:
  %2 := Phi int @test.testMatchExpressionBlockValues:2, @0:1
  Call void @test.use<Int>(%2)
  Ret
}

func void @test.testMatchStatementInExpressionPosition(long %0) {
  %1 := Eq long %0, 3
  branch %1, @0, @3
label @0:
  %2 := Eq long %0, 1
  branch %2, @2, @1
label @1:
  continue @2
label @2:
  %3 := Phi int @0:2, @1:1
  continue @3
label @3:
  %4 := Phi int @test.testMatchStatementInExpressionPosition:3, @2:%3
  Call void @test.use<Int>(%4)
  Ret
}

func void @test.testNestedMatchAndIf(long %0) {
  %1 := Eq long %0, 3
  branch %1, @0, @10
label @0:
  %2 := Eq long %0, 1
  branch %2, @9, @1
label @1:
  %3 := Eq long %0, 3
  branch %3, @2, @5
label @2:
  %4 := Eq long %0, 1
  branch %4, @4, @3
label @3:
  continue @4
label @4:
  %5 := Phi int @2:2, @3:1
  continue @8
label @5:
  %6 := Eq long %0, 1
  branch %6, @7, @6
label @6:
  continue @7
label @7:
  %7 := Phi int @5:4, @6:3
  continue @8
label @8:
  %8 := Phi int @4:%5, @7:%7
  continue @9
label @9:
  %9 := Phi int @0:5, @8:%8
  continue @10
label @10:
  %10 := Phi int @test.testNestedMatchAndIf:6, @9:%9
  Call void @test.use<Int>(%10)
  Ret
}

func void @test.testZeroSizeMatch(long %0) {
  %1 := Eq long %0, 1
  branch %1, @0, @1
label @0:
  Call void @test.use<Bool>(1)
  continue @2
label @1:
  Call void @test.use<Bool>(3)
  continue @2
label @2:
  Call void @test.use<test.ZeroSize>()
  Ret
}

func void @test.testUnitMatch(int %0) {
  %1 := Eq int %0, 1
  branch %1, @3, @0
label @0:
  %2 := Eq int %0, 2
  branch %2, @3, @1
label @1:
  %3 := Eq int %0, 3
  branch %3, @2, @3
label @2:
  Call void @test.use<Int>(3)
  continue @3
label @3:
  Call void @test.use<Unit>()
  Ret
}

func void @test.testReturnBranch(int %0) {
  %1 := Eq int %0, 1
  branch %1, @1, @0
label @0:
  %2 := Eq int %0, 2
  branch %2, @1, @2
label @1:
  %3 := Phi int @test.testReturnBranch:1, @0:2
  Call void @test.use<Int>(%3)
  Ret
label @2:
  Ret
}

func void @test.testReturnBlockBranch(int %0) {
  %1 := Eq int %0, 1
  branch %1, @1, @0
label @0:
  %2 := Eq int %0, 2
  branch %2, @1, @2
label @1:
  %3 := Phi int @test.testReturnBlockBranch:1, @0:2
  Call void @test.use<Int>(%3)
  Ret
label @2:
  Call void @test.use<Bool>(3)
  Ret
}

func void @test.testDivergentExpressionBranch(int %0) {
  %1 := Eq int %0, 1
  branch %1, @1, @0
label @0:
  %2 := Eq int %0, 2
  branch %2, @1, @2
label @1:
  %3 := Phi int @test.testDivergentExpressionBranch:1, @0:2
  Call void @test.use<Int>(%3)
  Ret
label @2:
  CallBuiltin void myte_exit(1)
}

func void @test.testLoopDivergence(int %0) {
  %1 := Eq long 3, 3
  branch %1, @0, @3
label @0:
  %2 := Eq int %0, 1
  branch %2, @1, @2
label @1:
  Call void @test.use<Int>(1)
  continue @test.testLoopDivergence
label @2:
  %3 := Eq int %0, 2
  branch %3, @test.testLoopDivergence, @3
label @3:
  Ret
}

func void @test.use<Bool>(long %0) {
  Ret
}

func void @test.use<Function>(fn %0) {
  Ret
}

func void @test.use<Int>(int %0) {
  Ret
}

func void @test.use<Unit>() {
  Ret
}

func void @test.use<test.ZeroSize>() {
  Ret
}

func int @test.main() {
  Call void @test.use<Function>(@test.testMatchExpressionBlockValues)
  Call void @test.use<Function>(@test.testMatchStatementInExpressionPosition)
  Call void @test.use<Function>(@test.testNestedMatchAndIf)
  Call void @test.use<Function>(@test.testZeroSizeMatch)
  Call void @test.use<Function>(@test.testUnitMatch)
  Call void @test.use<Function>(@test.testReturnBranch)
  Call void @test.use<Function>(@test.testReturnBlockBranch)
  Call void @test.use<Function>(@test.testDivergentExpressionBranch)
  Call void @test.use<Function>(@test.testLoopDivergence)
  Ret 0
}