func void @test.testMatchExpressionBlockValues(bool %0) {
  %1 := Eq bool %0, false
  branch %1, @1, @0
label @0:
  continue @1
label @1:
  %2 := Phi int @test.testMatchExpressionBlockValues:2, @0:1
  Call void @test.use<Int>(%2)
  Ret
}

func void @test.testMatchStatementInExpressionPosition(bool %3) {
  branch %3, @2, @5
label @2:
  %4 := Eq bool %3, false
  branch %4, @4, @3
label @3:
  continue @4
label @4:
  %5 := Phi int @2:2, @3:1
  continue @5
label @5:
  %6 := Phi int @test.testMatchStatementInExpressionPosition:3, @4:%5
  Call void @test.use<Int>(%6)
  Ret
}

func void @test.testNestedMatchAndIf(bool %7) {
  branch %7, @6, @16
label @6:
  %8 := Eq bool %7, false
  branch %8, @15, @7
label @7:
  branch %7, @8, @11
label @8:
  %9 := Eq bool %7, false
  branch %9, @10, @9
label @9:
  continue @10
label @10:
  %10 := Phi int @8:2, @9:1
  continue @14
label @11:
  %11 := Eq bool %7, false
  branch %11, @13, @12
label @12:
  continue @13
label @13:
  %12 := Phi int @11:4, @12:3
  continue @14
label @14:
  %13 := Phi int @10:%10, @13:%12
  continue @15
label @15:
  %14 := Phi int @6:5, @14:%13
  continue @16
label @16:
  %15 := Phi int @test.testNestedMatchAndIf:6, @15:%14
  Call void @test.use<Int>(%15)
  Ret
}

func void @test.testZeroSizeMatch(bool %16) {
  %17 := Eq bool %16, false
  branch %17, @17, @18
label @17:
  Call void @test.use<Bool>(false)
  continue @19
label @18:
  Call void @test.use<Bool>(true)
  continue @19
label @19:
  Call void @test.use<test.ZeroSize>()
  Ret
}

func void @test.testUnitMatch(int %18) {
  %19 := Eq int %18, 1
  branch %19, @23, @20
label @20:
  %20 := Eq int %18, 2
  branch %20, @23, @21
label @21:
  %21 := Eq int %18, 3
  branch %21, @22, @23
label @22:
  Call void @test.use<Int>(3)
  continue @23
label @23:
  Call void @test.use<Unit>()
  Ret
}

func void @test.testReturnBranch(int %22) {
  %23 := Eq int %22, 1
  branch %23, @25, @24
label @24:
  %24 := Eq int %22, 2
  branch %24, @25, @26
label @25:
  %25 := Phi int @test.testReturnBranch:1, @24:2
  Call void @test.use<Int>(%25)
  Ret
label @26:
  Ret
}

func void @test.testReturnBlockBranch(int %26) {
  %27 := Eq int %26, 1
  branch %27, @28, @27
label @27:
  %28 := Eq int %26, 2
  branch %28, @28, @29
label @28:
  %29 := Phi int @test.testReturnBlockBranch:1, @27:2
  Call void @test.use<Int>(%29)
  Ret
label @29:
  Call void @test.use<Bool>(true)
  Ret
}

func void @test.testDivergentExpressionBranch(int %30) {
  %31 := Eq int %30, 1
  branch %31, @31, @30
label @30:
  %32 := Eq int %30, 2
  branch %32, @31, @32
label @31:
  %33 := Phi int @test.testDivergentExpressionBranch:1, @30:2
  Call void @test.use<Int>(%33)
  Ret
label @32:
  CallBuiltin void myte_exit(1)
}

func void @test.testLoopDivergence(int %34) {
  branch true, @33, @36
label @33:
  %35 := Eq int %34, 1
  branch %35, @34, @35
label @34:
  Call void @test.use<Int>(1)
  continue @test.testLoopDivergence
label @35:
  %36 := Eq int %34, 2
  branch %36, @test.testLoopDivergence, @36
label @36:
  Ret
}

func void @test.use<Bool>(bool %37) {
  Ret
}

func void @test.use<Function>(fn %38) {
  Ret
}

func void @test.use<Int>(int %39) {
  Ret
}

func void @test.use<Unit>() {
  Ret
}

func void @test.use<test.ZeroSize>() {
  Ret
}

func int @test.main() {
  Call void @test.use<Function>(@test.testMatchExpressionBlockValues)
  Call void @test.use<Function>(@test.testMatchStatementInExpressionPosition)
  Call void @test.use<Function>(@test.testNestedMatchAndIf)
  Call void @test.use<Function>(@test.testZeroSizeMatch)
  Call void @test.use<Function>(@test.testUnitMatch)
  Call void @test.use<Function>(@test.testReturnBranch)
  Call void @test.use<Function>(@test.testReturnBlockBranch)
  Call void @test.use<Function>(@test.testDivergentExpressionBranch)
  Call void @test.use<Function>(@test.testLoopDivergence)
  Ret 0
}