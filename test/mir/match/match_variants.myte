module test

type V1 =
  | Enum1
  | Tuple1 (Bool, Int)
  | Record1 { foo: Int, bar: Byte }

type V2 =
  | Tuple2 (Bool, V1)
  | Enum2
  | Record2 { foo: V2, bar: Bool }

// Exhaustive, only check tags
fun test1(x: V1): Int =
  match (x) {
    | Tuple1 _ -> 1
    | Enum1 -> 2
    | Record1 _ -> 3
  }

// Check inner elements
fun test2(x: V1): Int =
  match (x) {
    | Record1 { foo: 2, ... } -> 1
    | Tuple1 (_, 4) -> 2
    | Record1 { bar: 2, foo: _ } -> 3
    | Tuple1 (true, _) -> 4
    | _ -> 5
  }

// Nested variants
fun test3(x: V2): Int =
  match (x) {
    | Tuple2 (_, Tuple1 (true, _)) -> 1
    | Record2 { foo: Record2 { foo: Enum2, ... }, ... } -> 2
    | _ -> 3
  }

// Deeply nested variant only loads each check once
fun test4(x: V2): Int =
  match (x) {
    | Record2 { foo: Record2 { foo: Record2 { foo: Tuple2 (_, Tuple1 (true, 1 | 2 | 3)), ... }, ... }, ... } -> 1
    | Record2 { foo: Record2 { foo: Record2 _, ... }, ... } -> 2
    | _ -> 3
  }

// Binds inner values
fun test5(x: V1): Int =
  match (x) {
    | Record1 { foo: x, bar } -> if (bar == 1) { x } else { bar.toInt() }
    | Tuple1 (foo, bar) -> if (foo) { bar } else { 2 }
    | Enum1 -> 3
  }

// Binding nested inner values
fun test6(x: V2): V2 =
  match (x) {
    // Extract inner value
    | Record2 { foo: Record2 { foo: Record2 { foo: Record2 { foo: x, bar: true }, ...}, ... }, ... } -> x
    // Bind pattern, use already loaded value
    | Record2 { foo: Record2 { foo: (Enum2 as x), ... }, ... } -> x
    | Record2 { foo: (Record2 { foo: Record2 { foo: Record2 { bar: false, ... }, ... }, ... } as x), ... } -> x
    | other -> other
  }

type V3 =
  | Enum31
  | Enum32
  | Enum33

fun test7(x: V3): Int =
  match (x) {
    | Enum31 -> 5
    | Enum32 -> 6
    | Enum33 -> 7
  }

fun main() {}