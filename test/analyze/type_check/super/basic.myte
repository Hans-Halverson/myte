module test

trait SuperTrait1 {}

type SubType1 (Int)
methods SubType1 {
  implements SuperTrait1
}

trait Trait1 {
  fun foo(): SubType1 {
    return SubType1 (1);
  }

  fun inherited() {}
}

type RecordLikeTrait1 { foo: Long, field: Int }

type Type1 { fooField: Int }
methods Type1 {
  implements Trait1

  override fun foo(): SubType1 {
    return SubType1 (1);
  }

  fun bar() {
    // Intentionally wrong to print type
    (super.foo(): Bool);
    (super.foo(): SubType1);

    // Super can be shadowed
    val super: RecordLikeTrait1 = RecordLikeTrait1 { foo: 1, field: 2 };
    // Intentionally wrong to print type
    (super.foo: Unit);
    (super: Unit);
  }

  fun superCallInheritedError() {
    // Fine to call inherited methods via this
    this.inherited();
    // Cannot call inherited methods via super
    super.inherited();
  }

  fun superCallNonexistent() {
    // Cannot call method that doesn't exist
    super.nonexist();
  }

  fun testUnresolvedSuper() {
    super;
    use(super); 
  }

  fun superFieldAccess() {
    (super.field: Unit);
    super.field = ();

    // Cannot reassign 
    super.field = 1;
  }
}

trait Trait2 {
  fun a(): Bool
}

trait Trait3 {
  extends Trait2

  override fun a(): Bool = true

  fun b(): Bool

  fun superCallSignatureErrors() {
    super.a();
    super.b();
  }

  fun superNonexist() {
    super.c();
  }
}

fun use<T>(x: T) {}

fun main() {}