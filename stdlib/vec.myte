module std.vec

import std.int.Int
import std.iterator.{Iterable, Iterator}
import std.memory.Array
import std.option.{None, Option, Some}
import std.sys.abort

/*
 * A resizable container of elements.
 */
type Vec<T> {
  data: Array<T>,
  size: Int,
  capacity: Int,
}

methods Vec<T> {
  static fun new<T>(): Vec<T> {
    return Vec {
      data: Array.new(0),
      size: 0,
      capacity: 0,
    };
  }

  fun get(index: Int): T {
    if (index < 0 || index >= this.size) {
      abort();
    }

    return this.data[index];
  }

  fun set(index: Int, item: T) {
    if (index < 0 || index >= this.size) {
      abort();
    }

    this.data[index] = item;
  }

  fun push(x: T) {
    if (this.size == this.capacity) {
      this.resize();
    }

    this.data[this.size] = x;
    this.size = this.size + 1;
  }

  fun resize() {
    val oldCapacity = this.capacity;
    val newCapacity = oldCapacity == 0 ? 1 : oldCapacity * 2;
    this.capacity = newCapacity;

    val newData: Array<T> = Array.new(newCapacity);
    Array.copy(newData, 0, this.data, 0, oldCapacity);
    this.data = newData;
  }
}

/*
 * An iterator over a Vec. Contains both the Vec and the index of the next item to visit.
 */
type VecIterator<T> { data: Array<T>, size: Int, index: Int }

methods Vec<T> {
  implements Iterable<T>

  override fun toIterator(): VecIterator<T> {
    val Vec { data, size, ... } = this;
    return VecIterator { data, size, index: 0 };
  }
}

methods VecIterator<T> {
  implements Iterator<T>

  override fun next(): Option<T> {
    val index = this.index;
    if (index >= this.size) {
      return None;
    }

    val value = this.data[index];
    this.index = index + 1;

    return Some (value);
  }
}
