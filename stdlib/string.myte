module std.string

import std.bool.Bool
import std.byte.Byte
import std.hash
import std.hash.Hashable
import std.int.Int
import std.iterator.Iterator
import std.memory.Array
import std.ops.Equatable
import std.option.{None, Option, Some}
import std.sys.abort
import std.vec.Vec

type alias Char = Byte

type String {
  data: Array<Char>,
  size: Int,
  capacity: Int,
}

methods String {
  static fun new(): String {
    return String {
      data: Array.new(0),
      size: 0,
      capacity: 0,
    };
  }

  static fun newWithCapacity(capacity: Int): String {
    return String {
      data: Array.new(capacity),
      size: 0,
      capacity,
    };
  }

  fun get(index: Int): Char {
    if (index >= this.size) {
      abort();
    }

    return this.data[index];
  }

  fun set(index: Int, item: Char) {
    if (index >= this.size) {
      abort();
    }

    this.data[index] = item;
  }

  fun push(char: Char) {
    if (this.size == this.capacity) {
      this.resize();
    }

    this.data[this.size] = char;
    this.size = this.size + 1;
  }

  fun append(str: String) {
    val newSize = this.size + str.size;
    if (newSize > this.capacity) {
      this.resizeWithMinCapacity(newSize);
    }

    Array.copy(this.data, this.size, str.data, 0, str.size);
    this.size = newSize;
  }
  
  fun appendBytes(data: Array<Byte>, offset: Int, size: Int) {
    val newSize = this.size + size;
    if (newSize > this.capacity) {
      this.resizeWithMinCapacity(newSize);
    }

    Array.copy(this.data, this.size, data, offset, size);
    this.size = newSize;
  }

  fun substring(start: Int, size: Int): String {
    if (start < 0 || size < 0 || start + size > this.size) {
      abort();
    }

    val string = String { data: Array.new(size), size, capacity: size };
    Array.copy(string.data, 0, this.data, start, size);

    return string;
  }

  static fun repeat(string: String, count: Int): String {
    if (count <= 0) {
      return "";
    }

    val newString = String.newWithCapacity(string.size * count);
    for (_ in 0.to(count)) {
      newString.append(string);
    }

    return newString;
  }

  fun resize() {
    val oldCapacity = this.capacity;
    val newCapacity = if (oldCapacity == 0) {
      1
    } else {
      oldCapacity * 2
    };
  
    this.capacity = newCapacity;

    val newData: Array<Char> = Array.new(newCapacity);
    Array.copy(newData, 0, this.data, 0, oldCapacity);
    this.data = newData;
  }

  fun resizeWithMinCapacity(minCapacity: Int) {
    val oldCapacity = this.capacity;
    var newCapacity = if (oldCapacity == 0) {
      1
    } else {
      oldCapacity * 2
    };

    if (newCapacity < minCapacity) {
      newCapacity = minCapacity;
    }
    this.capacity = newCapacity;

    val newData: Array<Char> = Array.new(newCapacity);
    Array.copy(newData, 0, this.data, 0, oldCapacity);
    this.data = newData;
  }

  fun reverse() {
    val size = this.size;
    val oldData = this.data;
    val newData: Array<Char> = Array.new(size);
    this.data = newData;
    this.capacity = size;

    for (i in 0.to(size)) {
      newData[size - (i + 1)] = oldData[i];
    }
  }

  fun clone(): String {
    val capacity = this.capacity;
    val data: Array<Byte> = Array.new(capacity);
    val size = this.size;

    Array.copy(data, 0, this.data, 0, this.size);

    return String { data, size, capacity };
  }

  fun toCString(): String {
    val cString = this.clone();
    cString.push(0);

    return cString;
  }

  /**
   * Convert a c-string (a null terminated byte string) to a string.
   */
  static fun fromCString(cString: Array<Byte>): String {
    val str = "";
    var i = 0;
    while (cString[i] != 0) {
      str.push(cString[i]);
      i = i + 1;
    }

    return str;
  }

  /**
   * Return an iterator over this String's bytes.
   */
  fun bytes(): StringByteIterator =
    StringByteIterator { data: this.data, size: this.size, index: 0 }
}

methods String {
  implements Equatable

  override fun equals(other: String): Bool {
    val size = this.size;
    if (size != other.size) {
      return false;
    }

    val thisData = this.data;
    val otherData = other.data;

    for (i in 0.to(size)) {
      if (thisData[i] != otherData[i]) {
        return false;
      }
    }

    return true;
  }
}

/**
 * A trait for anything that has a String representation.
 */
trait ToString {
  fun toString(): String
}

methods String {
  implements ToString

  override fun toString(): String = this
}

methods String {
  implements Hashable

  override fun hash(): Int {
    var n = 0;
    for (byte in this.bytes()) {
      n = hash.combine(n, byte.toInt());
    }

    return n;
  }
}

/**
 * An iterator over the bytes of a String.
 */
type StringByteIterator { data: Array<Byte>, size: Int, index: Int }

methods StringByteIterator {
  implements Iterator<Byte>

  override fun next(): Option<Byte> {
    if (this.index >= this.size) {
      return None;
    }

    val value = this.data[this.index];
    this.index += 1;

    return Some (value);
  }
}